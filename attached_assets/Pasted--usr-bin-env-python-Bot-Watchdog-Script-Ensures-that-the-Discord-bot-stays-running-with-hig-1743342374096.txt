#!/usr/bin/env python
"""
Bot Watchdog Script
Ensures that the Discord bot stays running with high uptime by restarting it if needed.
"""

import os
import sys
import time
import subprocess
import logging
import requests
import signal
import psutil

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler("watchdog.log")
    ]
)
logger = logging.getLogger("watchdog")

CHECK_INTERVAL = 60  # Check every 60 seconds
HEALTH_CHECK_URL = "http://0.0.0.0:5000/healthz"
HEALTH_CHECK_TIMEOUT = 10

def kill_process_by_name(name):
    """Kill processes whose cmdline contains the given name."""
    for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
        try:
            cmdline = " ".join(proc.info['cmdline']) if proc.info['cmdline'] else ""
            if name in cmdline:
                logger.info(f"Killing process {proc.info['pid']}: {cmdline}")
                try:
                    proc.terminate()
                    proc.wait(timeout=3)
                except (psutil.NoSuchProcess, psutil.TimeoutExpired):
                    proc.kill()
        except (psutil.NoSuchProcess, psutil.AccessDenied):
            pass

def is_bot_running():
    """Check if the bot is responsive via its health endpoint."""
    try:
        response = requests.get(HEALTH_CHECK_URL, timeout=HEALTH_CHECK_TIMEOUT)
        if response.status_code == 200:
            data = response.json()
            if data.get('status') in ['healthy', 'warning']:
                return True
            logger.warning(f"Unhealthy status: {data.get('status')}")
        else:
            logger.warning(f"Health check failed with status code: {response.status_code}")
        return False
    except requests.Timeout:
        logger.warning("Health check timed out")
        return False
    except Exception as e:
        logger.error(f"Error checking bot health: {e}")
        return False

def start_bot():
    """Start the bot by calling 'python main.py'."""
    try:
        cmd = ["python", "main.py"]
        logger.info(f"Starting bot: {' '.join(cmd)}")
        process = subprocess.Popen(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            env=os.environ.copy()
        )
        time.sleep(10)
        if process.poll() is None:
            logger.info("Bot started successfully")
            return process
        else:
            stdout, stderr = process.communicate()
            logger.error(f"Bot failed to start. Exit code: {process.returncode}")
            logger.error(f"STDOUT: {stdout}")
            logger.error(f"STDERR: {stderr}")
            return None
    except Exception as e:
        logger.error(f"Error starting bot: {e}")
        return None

def check_and_create_watchdog_lock():
    """Create a lock file for the watchdog to prevent multiple instances."""
    lock_file = "watchdog.lock"
    current_pid = os.getpid()
    if os.path.exists(lock_file):
        try:
            with open(lock_file, 'r') as f:
                old_pid = int(f.read().strip())
                try:
                    proc = psutil.Process(old_pid)
                    if "keep_running.py" in " ".join(proc.cmdline()):
                        logger.warning(f"Another watchdog is already running with PID {old_pid}. Exiting.")
                        sys.exit(0)
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    logger.info(f"Removing stale watchdog lock from PID {old_pid}")
        except Exception:
            logger.warning("Invalid watchdog lock file, overwriting")
    try:
        with open(lock_file, 'w') as f:
            f.write(str(current_pid))
        logger.info(f"Created watchdog lock file with PID {current_pid}")
    except Exception as e:
        logger.error(f"Failed to create watchdog lock: {e}")

def main():
    logger.info("Bot watchdog started")
    check_and_create_watchdog_lock()
    kill_process_by_name("main.py")
    kill_process_by_name("python")
    if os.path.exists("bot.lock"):
        try:
            os.remove("bot.lock")
            logger.info("Removed stale bot.lock file")
        except Exception as e:
            logger.error(f"Failed to remove stale bot.lock: {e}")
    process = start_bot()
    restart_count = 0
    last_restart_time = 0
    rapid_restart_count = 0
    try:
        while True:
            if not is_bot_running():
                current_time = time.time()
                logger.warning("Bot is not running or unresponsive, restarting...")
                if current_time - last_restart_time < 60:
                    rapid_restart_count += 1
                    if rapid_restart_count >= 3:
                        logger.critical(f"Multiple rapid restarts detected ({rapid_restart_count}); cooling down for 300 seconds.")
                        time.sleep(300)
                        rapid_restart_count = 0
                else:
                    rapid_restart_count = 0
                kill_process_by_name("main.py")
                kill_process_by_name("python")
                time.sleep(5)
                process = start_bot()
                restart_count += 1
                last_restart_time = current_time
                logger.info(f"Bot restarted {restart_count} times")
            else:
                logger.info("Bot is running correctly")
            time.sleep(CHECK_INTERVAL)
    except KeyboardInterrupt:
        logger.info("Watchdog shutting down due to keyboard interrupt")
        if process and process.poll() is None:
            process.terminate()
            try:
                process.wait(timeout=5)
            except subprocess.TimeoutExpired:
                process.kill()

if __name__ == "__main__":
    main()
