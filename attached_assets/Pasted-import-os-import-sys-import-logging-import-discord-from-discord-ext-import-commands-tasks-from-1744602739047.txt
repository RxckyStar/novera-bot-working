import os
import sys
import logging
import discord
from discord.ext import commands, tasks
from discord import app_commands
import discord.ui as ui
import asyncio
import time
import math
import random
import re
import psutil
from typing import Optional, List, Union, Dict, Any, Tuple
from flask import Flask, jsonify
import threading
import utils
import atexit
import signal
from datetime import datetime, timedelta
import json
import subprocess
import traceback
# Import proper ConnectionClosedError class from websockets
try:
    from websockets.exceptions import ConnectionClosedError
except ImportError:
    # If websockets isn't directly accessible, we'll use string matching later
    ConnectionClosedError = None
from timeout_handlers import with_timeout, wait_for_safe

# Import our instance manager
from instance_manager import (
    claim_instance, release_instance, kill_other_instances, write_pid_file,
    WATCHDOG_PID_FILE, BOT_PID_FILE, WEB_PID_FILE
)

# Configure logging for better error tracking
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler("bot.log")
    ]
)
logger = logging.getLogger(__name__)

# Enhanced token validation and import with fallback mechanism
try:
    # Check for token cache refresh flag first (from token_refresher.py)
    token_cache_refresh = os.path.exists("refresh_token_cache")
    if token_cache_refresh:
        try:
            os.remove("refresh_token_cache")
            logger.info("Token cache refresh flag detected - forcing token reload")
        except Exception:
            pass
        
    # Import from config with our enhanced token handling
    from config import TOKEN, COMMAND_PREFIX, DATA_FILE, get_token, load_token_from_cache, clean_token, validate_token
    
    if TOKEN is None:
        logger.critical("TOKEN is None from config, attempting emergency retrieval")
        try:
            # First try from environment with advanced validation
            TOKEN = get_token()
            logger.info("Successfully retrieved token from get_token()")
        except Exception as e:
            logger.critical(f"Emergency token retrieval failed: {e}")
            
            # Try loading directly from cache as last resort
            try:
                cached_token = load_token_from_cache()
                if cached_token:
                    TOKEN = cached_token
                    logger.warning("Using emergency cached token after get_token() failure")
                else:
                    logger.critical("No cached token available for emergency recovery")
                    TOKEN = None
            except Exception as cache_err:
                logger.critical(f"Cache retrieval also failed: {cache_err}")
                TOKEN = None
    
    # Final validation
    if TOKEN:
        # Clean the token to ensure it's correctly formatted
        TOKEN = clean_token(TOKEN)
        # Validate token format
        if not validate_token(TOKEN):
            logger.critical(f"Invalid token format: length={len(TOKEN)}, validation failed")
            # Seek a direct environment token as absolute last resort
            raw_token = os.environ.get('DISCORD_TOKEN')
            if raw_token and len(raw_token) >= 50:
                logger.warning("Using raw environment token as last resort")
                TOKEN = clean_token(raw_token)
            else:
                TOKEN = None
    
except ImportError as e:
    logger.critical(f"Failed to import config: {e}")
    # Fallback to direct env var with minimal validation
    TOKEN = os.environ.get('DISCORD_TOKEN')
    if TOKEN:
        TOKEN = TOKEN.strip().replace('"', '').replace("'", '')
    COMMAND_PREFIX = "!"
    DATA_FILE = "member_data.json"
    
    # Create very simple token cache if we have a valid token
    if TOKEN and len(TOKEN) >= 50:
        try:
            import json
            from datetime import datetime
            with open("token_cache.json", 'w') as f:
                json.dump({
                    "token": TOKEN,
                    "timestamp": datetime.now().isoformat(),
                    "validated": True,
                    "emergency": True
                }, f)
            logger.info("Created emergency token cache during import failure")
        except Exception as cache_err:
            logger.warning(f"Failed to create emergency token cache: {cache_err}")

from data_manager import DataManager
from activity_tracker import ActivityTracker
from utils import (
    has_value_management_role, format_ranking_message,
    has_spank_permission, get_random_spank_response,
    get_random_headpat_response, get_spank_warning_response
)
from leaving_messages import LEAVING_MESSAGES  # Import leaving messages
# Import tryouts module for player evaluations
# We'll import only the module, not specific functions to avoid circular imports
import tryouts
logger.info("Successfully imported tryouts module")

# Initialize the active_tryouts dictionary and share it with the tryouts module
active_tryouts = {}
tryouts.set_active_tryouts(active_tryouts)

# =============================
# MOMMY PHRASE VARIANTS WITH EMOJIS
# =============================
MOMMY_ERROR_VARIANTS = [
    "ðŸ˜± Oh dear, Mommy had a little boo boo! Please try again, sweetie! ðŸ˜¢",
    "ðŸ˜“ Oopsie, something went awry, my darling! Mommy is on it! ðŸŒˆ",
    "ðŸ˜– Oh no dear, Mommy's system just tripped over a rainbow! Try again, honey! ðŸ’•",
    "ðŸ˜ž Yikes, that didn't go as planned, sweetie! Mommy needs a moment! ðŸ˜‡",
    "ðŸ˜¬ Whoopsie, Mommy encountered a tiny hiccup there! Please forgive me, darling! ðŸ˜˜",
    "ðŸ¥º Aww no, something went wrong in Mommy's circuits! Let's try that again, precious! ðŸ’«",
    "ðŸ˜… Oops! Mommy stumbled a bit there! Give me another chance, sweetie! ðŸŒ¸",
    "ðŸ˜” Oh my, that didn't work quite right! Mommy needs to fix her makeup, darling! ðŸŽ€",
    "ðŸ¤• Ouchie! Mommy had a small accident! Let's give it another shot, love! ðŸ’",
    "ðŸ˜³ Oh goodness, that wasn't supposed to happen! Mommy will do better, sweetheart! âœ¨"
]

MOMMY_SUCCESS_VARIANTS = [
    "ðŸŽ‰ Yay, Mommy is so proud of you, darling! Fantastic work! ðŸ’–",
    "ðŸ‘ Hooray, you've done it, sweetie! Mommy loves your effort! ðŸŒŸ",
    "ðŸ† Bravo, my precious! Mommy is absolutely delighted by your performance! ðŸ˜",
    "âœ¨ Wonderful, darlingâ€”Mommy adores your work! Keep shining! ðŸŒˆ",
    "ðŸ’ Splendid job, sweetheart! Mommy is cheering for you with all her heart! ðŸ’",
    "ðŸŒº You're making Mommy's heart flutter with joy, darling! Outstanding! ðŸ’«",
    "ðŸŽˆ That's my talented little star! Mommy couldn't be more pleased! ðŸ¥°",
    "ðŸŒŸ Look at you go, precious! Mommy's heart is bursting with pride! ðŸ’•",
    "ðŸ… Simply perfect, my love! You always know how to make Mommy smile! ðŸ¤—",
    "ðŸŒ¸ Magnificent work, sweetie! You're everything Mommy hoped for and more! ðŸ’–"
]

MOMMY_PERMISSION_DENIED = [
    "ðŸš« Oh dear, you don't have permission for that, my love! Please ask a staff member, darling! ðŸ™…",
    "âŒ Oopsie, you're not allowed to do that, sweetheart! Mommy says no, try again later! ðŸ™‡",
    "ðŸ™… Oh no, darling, that command is off limits for you! Please be patient, sweetie! ðŸ¤—",
    "ðŸ›‘ Yikes, permission denied, my dear! Mommy is sorry but you can't do that now! ðŸ˜”",
    "âŽ Oh dear, you lack the required permission, my love! Please check with staff, darling! ðŸ¤·",
    "ðŸ”’ Not so fast, precious! That's for special permissions only! Ask staff for help! ðŸ’•",
    "â›” Aww honey, Mommy can't let you do that just yet! Speak with staff first! ðŸŽ€",
    "ðŸš§ Hold on sweetie, that area is restricted! Let's get proper permission first! ðŸ’«",
    âš ï¸ Sorry darling, but Mommy must protect her special commands! Ask staff nicely! ðŸŒ¸",
    "ðŸ” That's under lock and key, my love! Get staff approval first! âœ¨"
]

# Responses when a user has a value greater than 0
MOMMY_CHECKVALUE_VARIANTS = [
    "ðŸ’– Darling, your value sparkles at Â¥{value} million! Mommy is so proud of you! âœ¨",
    "ðŸ’Ž Sweetheart, your value shines at an amazing Â¥{value} millionâ€”keep dazzling, my star! ðŸŒŸ",
    "ðŸ’° Oh my, your value stands tall at Â¥{value} million! Mommy is over the moon for you! ðŸŽ‰",
    "ðŸŒˆ Bravo, my precious! Your value is a fabulous Â¥{value} million. Mommy loves your shine! ðŸ˜",
    "ðŸ”¥ Darling, you're on fire with a value of Â¥{value} million! Keep making Mommy proud! ðŸ¥°",
    "ðŸ’« Look at that gorgeous value of Â¥{value} million! You're growing so beautifully! ðŸŽ€",
    "ðŸ’ Oh sweetie, Â¥{value} million looks absolutely stunning on you! Keep climbing! ðŸŒ¸",
    "âœ¨ What a precious value of Â¥{value} million! Mommy's little star is shining bright! ðŸ’–",
    "ðŸŒŸ Darling, Â¥{value} million suits you perfectly! You're becoming so valuable! ðŸ’«",
    "ðŸ’… Serving elegance with that Â¥{value} million value! Mommy is living for it! ðŸŽ­",
    "ðŸ’« Oh la la! Â¥{value} million value? Mommy thinks you're absolutely fabulous! ðŸ’ƒ",
    "ðŸŒ  Sweetheart, your value of Â¥{value} million has Mommy absolutely swooning! ðŸ˜",
    "ðŸ’ With a value of Â¥{value} million, you're making Mommy's heart flutter! So proud! ðŸ¦‹",
    "ðŸ† Darling, a value of Â¥{value} million? You're becoming Mommy's champion! ðŸŽ–ï¸",
    "ðŸ’Ž Mommy is blown away by your Â¥{value} million value! You're becoming such a gem! ðŸ’",
    "âœ¨ Precious one, your Â¥{value} million value has Mommy seeing stars! Keep shining! â­",
    "ðŸŒˆ With Â¥{value} million in value, you're painting Mommy's world with color! ðŸŽ¨",
    "ðŸš€ Shooting to the stars with that Â¥{value} million value! Mommy's so impressed! ðŸŒ ",
    "ðŸ‘‘ Wearing that Â¥{value} million value like royalty! Mommy bows to you, my liege! ðŸ§Žâ€â™€ï¸",
    "ðŸŒº Blooming beautifully with a Â¥{value} million value! Mommy loves watching you grow! ðŸŒ±"
]

# Responses when a user has under 100 value - sassy and unimpressed responses
MOMMY_LOW_VALUE_VARIANTS = [
    "ðŸ’¸ Only Â¥{value} million? Darling, Mommy spends that much on a Gucci bag! You need to aim higher! ðŸ‘œ",
    "ðŸ¤ Â¥{value} million? Is that all you've got, sweetie? Mommy's manicure costs more than that! ðŸ’…",
    "ðŸ˜’ Hmm, Â¥{value} million... Mommy spent more than that on breakfast this morning. Do better, darling! ðŸ³",
    "ðŸ§ Â¥{value} million? Oh, bless your heart! That's barely enough to buy Mommy's favorite lipstick! ðŸ’„",
    "ðŸ™„ Darling, Â¥{value} million is what Mommy tips her hairstylist! You're going to need to work harder! ðŸ’‡â€â™€ï¸",
    "ðŸ˜¬ Oh sweetie... Â¥{value} million? Mommy's champagne costs more than that! Time to level up! ðŸ¾",
    "ðŸ‘  Â¥{value} million wouldn't even buy one of Mommy's Louboutins, darling! Keep grinding! ðŸ‘ ",
    "ðŸ¥± Mommy yawns at your Â¥{value} million value. That's pocket change for a bad bitch like me! ðŸ’°",
    "ðŸ’³ Â¥{value} million? Mommy spends that much on a single swipe of her credit card! Try harder, precious! ðŸ’³",
    "ðŸ¤·â€â™€ï¸ Â¥{value} million? Darling, Mommy misplaces more than that in her couch cushions! Do better! ðŸ›‹ï¸",
    "ðŸ‘› Oh honey, Â¥{value} million is just the loose change in Mommy's purse! You're going to need more to impress me! ðŸ’µ",
    "ðŸ¸ Â¥{value} million? That's barely enough for Mommy's martini, sweetie! Keep hustling! ðŸ¸",
    "ðŸ‘‘ Â¥{value} million is what Mommy pays her assistant to fetch coffee, darling! Aim higher! â˜•",
    "ðŸ’ Oh dear, Â¥{value} million wouldn't even buy the box for Mommy's jewelry! We need to work on this! ðŸ’Ž",
    "ðŸ§  Mommy's thinking... Â¥{value} million is cute, but it's giving 'allowance' not 'income'! Level up, sweetie! ðŸ“ˆ",
    "ðŸ‘œ Â¥{value} million? Mommy wouldn't even bend down to pick that up off the sidewalk! Try harder, love! ðŸš¶â€â™€ï¸",
    "ðŸŽ­ With Â¥{value} million, you're still in the nosebleed section of life, darling! Mommy sits front row! ðŸŽŸï¸",
    "ðŸ›ï¸ Oh sweetie, Â¥{value} million is what Mommy spends at duty-free! You've got potential though! âœˆï¸",
    "ðŸ•¶ï¸ Â¥{value} million? Mommy's sunglasses cost more, darling! But keep working, Mommy believes in you! ðŸ˜Ž",
    "ðŸ¥‚ Hmm, Â¥{value} million... That wouldn't even cover Mommy's weekend brunch! Keep grinding, sweetie! ðŸ½ï¸"
]

# Responses when a user has 0 value
MOMMY_ZERO_VALUE_VARIANTS = [
    # Original supportive responses
    "ðŸ’– Oh sweetie, your value is just starting to bloom at Â¥0 million! Mommy believes in your potential! âœ¨",
    "ðŸŒ± Darling, everyone starts at Â¥0 million! Mommy can't wait to see how you'll grow! ðŸŒ¿",
    "ðŸ¤— No value yet, my precious? That just means you've got nowhere to go but up! Mommy's cheering for you! ðŸ“ˆ",
    "ðŸ’Ž Value isn't just a number, sweetie! Your Â¥0 million is just the beginning of your journey! ðŸš€",
    "ðŸŒŸ Zero today, hero tomorrow! Mommy believes your value will skyrocket soon! ðŸ’«",
    "ðŸ”® Mommy sees great value in your future, darling! Your Â¥0 million is just temporary! â³",
    "ðŸ’• Sometimes the most precious gems start unpolished! Your Â¥0 million value won't stay that way for long! ðŸ’",
    "ðŸŒˆ Don't worry about that Â¥0 million, sweetie! Mommy knows you're priceless already! ðŸ’",
    "ðŸŒ  Your star is just beginning to shine with Â¥0 million! Mommy knows you'll be dazzling soon! âœ¨",
    "ðŸ¤© Oh darling, your value of Â¥0 million just means you're a blank canvas ready for greatness! ðŸŽ¨",
    
    # New sassy/teasing responses
    "ðŸ˜‚ Â¥0 million? Oh honey, that's not a value, that's a void! Did you even try yet, sweetie? ðŸ¤­",
    "ðŸ‘» Â¥0 million? Darling, ghosts have more substance than your value right now! Time to materialize something! ðŸ’¨",
    "ðŸ§® Mommy's calculator is broken - it keeps saying your value is Â¥0 million! Have you considered actually doing something? ðŸ”§",
    "ðŸ” Mommy's looking for your value but all she sees is Â¥0 million! Are you playing hide and seek with your potential? ðŸ™ˆ",
    "ðŸœï¸ Your value is like a desert mirage - Mommy can see Â¥0 million when she gets close! Let's find some real water, shall we? ðŸ’¦",
    "ðŸ“‰ With Â¥0 million, your value chart is flatter than Mommy's champagne after a week! Let's add some bubbles, darling! ðŸ¾",
    "ðŸª« Your value battery is showing Â¥0 million! Have you tried turning yourself off and on again, sweetie? ðŸ”Œ",
    "ðŸ¦– Your Â¥0 million value is so extinct, it belongs in a museum with the dinosaurs! Let's evolve, shall we? ðŸ§ª",
    "ðŸ‘‘ With Â¥0 million, you're the undisputed monarch of the Nothing Kingdom! Ready to expand your territories, darling? ðŸ—ºï¸",
    "ðŸŒµ Your value of Â¥0 million is like a cactus without spines - not even interesting enough to hurt! Add some personality, sweetie! ðŸŒ¸",
    "ðŸ§Š Â¥0 million? Mommy's seen more value in melting ice cubes! At least they become water eventually! â„ï¸",
    "ðŸŽ® Â¥0 million? Darling, even NPCs have more utility than that! Are you playing the game or just decorating the screen? ðŸ•¹ï¸",
    "ðŸ“± Your value of Â¥0 million reminds Mommy of her phone at 1% - barely registering and about to disappear! Plug in, sweetie! ðŸ”‹",
    "ðŸš« Â¥0 million? That's not a value, that's an error message! Have you tried actually participating, darling? ðŸ”„",
    "ðŸŽ­ With Â¥0 million, you're playing the role of 'extra' in your own life story! Ready for a speaking part yet, sweetie? ðŸŽ¬"
]

MOMMY_ACTIVITY_VARIANTS = [
    "ðŸŒŸ Darling, your activity score is {activity}! Mommy loves your energy! ðŸ”¥",
    "ðŸš€ Sweetheart, you've been super active with a score of {activity}! Mommy is impressed! ðŸ’ª",
    "ðŸŽŠ Oh my, you're buzzing with an activity score of {activity}! Keep it up, my love! ðŸ˜˜",
    "âš¡ Bravo, my precious! Your activity level is {activity}! Mommy is cheering you on! ðŸ‘",
    "ðŸŒˆ Darling, you're rocking it with an activity score of {activity}! Mommy is so proud! ðŸŽ‰",
    "ðŸ’« Look at you go with an activity score of {activity}! Such a busy bee! ðŸ",
    "ðŸŽ¯ Target achieved with {activity} activity points! Mommy loves your dedication! ðŸ’•",
    "ðŸŒº Blooming beautifully with {activity} activity! You're growing so well! ðŸŒ±",
    "â­ Shining bright with {activity} activity points! Keep sparkling, sweetie! âœ¨",
    "ðŸŽ¨ Painting the server active with a score of {activity}! Mommy's little artist! ðŸ–Œï¸"
]

# =============================
# GLOBAL DICTIONARIES FOR MATCHES & RESULTS
# =============================
# active_tryouts is now initialized above when importing tryouts module
active_matches = {}         # For match creation flows (keyed by creator id)
active_server_messages = {} # For server message interactive flows (keyed by author id)
active_matches_by_ad = {}   # {ad_message_id: MatchState} â€“ live matches waiting for team joins
pending_results = {}        # {creator_id: MatchState} â€“ finished matches pending result submission
pending_join_requests = {}  # For DM join requests

# =============================
# WEB SERVER FOR REPLIT AUTOSCALE
# =============================
app = Flask(__name__)
start_time = time.time()  # For uptime tracking
last_heartbeat = time.time()  # Track last activity for health checks

@app.route('/')
def home():
    return "ðŸŒŸ Novera Assistant is up and running, darling! ðŸŒŸ"

@app.route('/healthz')
def healthz():
    """Health check endpoint for monitoring"""
    bot_connected = bot is not None and bot.is_ready()
    last_heartbeat_age = time.time() - last_heartbeat if 'last_heartbeat' in globals() else 9999
    
    # Determine status based on bot connection and heartbeat age
    if not bot_connected:
        status = "disconnected"
    elif last_heartbeat_age > 120:  # No heartbeat in 2 minutes
        status = "stalled"
    elif last_heartbeat_age > 60:   # No heartbeat in 1 minute
        status = "warning"
    else:
        status = "healthy"
    
    # Get error count from the last hour if available
    error_count = 0
    try:
        if os.path.exists("bot_errors.log"):
            # Get recent errors by checking file modification time
            file_mod_time = os.path.getmtime("bot_errors.log")
            if time.time() - file_mod_time < 3600:  # File modified in the last hour
                with open("bot_errors.log", "r") as f:
                    errors = f.readlines()
                    # Count non-empty lines from the last 100 lines
                    error_count = sum(1 for line in errors[-100:] if line.strip())
    except Exception as e:
        logging.error(f"Error counting recent errors: {e}")
    
    # Gather latency information if available
    latency = -1
    try:
        if bot is not None and bot.is_ready() and bot.latency > 0:
            latency = round(bot.latency * 1000)  # Convert to ms
    except Exception as e:
        logging.error(f"Error getting bot latency: {e}")
    
    # Build and return the status object with detailed diagnostics
    status_data = {
        "status": status,
        "uptime": int(time.time() - start_time),
        "bot_connected": bot_connected,
        "last_heartbeat_age": int(last_heartbeat_age),
        "pid": os.getpid(),
        "recent_errors": error_count,
        "latency_ms": latency,
        "guilds_count": len(bot.guilds) if bot is not None and bot.is_ready() else 0,
        "diagnostics": {
            "memory_usage_mb": psutil.Process(os.getpid()).memory_info().rss / (1024 * 1024) if 'psutil' in sys.modules else -1,
            "cpu_percent": psutil.Process(os.getpid()).cpu_percent() if 'psutil' in sys.modules else -1,
            "thread_count": threading.active_count(),
            "connection_state": "connected" if bot_connected and hasattr(bot, 'ws') else "disconnected",
            "event_loop_active": True if bot_connected else False
        }
    }
    return jsonify(status_data)

@app.route('/monitor')
def monitor():
    """Monitoring endpoint for processed messages and bot state"""
    # Get heartbeat age
    last_heartbeat_age = time.time() - last_heartbeat if 'last_heartbeat' in globals() else 9999
    
    # Determine status based on bot connection and heartbeat age
    if not bot.is_ready():
        bot_status = "disconnected"
    elif last_heartbeat_age > 120:  # No heartbeat in 2 minutes
        bot_status = "stalled"
    elif last_heartbeat_age > 60:   # No heartbeat in 1 minute
        bot_status = "warning"
    else:
        bot_status = "healthy"
        
    # Get basic bot status
    status = {
        "status": bot_status,
        "uptime": int(time.time() - start_time),
        "pid": os.getpid(),
        "time": datetime.now().isoformat(),
        "last_heartbeat": last_heartbeat if 'last_heartbeat' in globals() else None,
        "heartbeat_age": int(last_heartbeat_age)
    }
    
    # Add processed messages info if available
    if hasattr(bot, "_processed_messages"):
        # Get a count of messages processed in the last minute
        current_time = time.time()
        recent_messages = {}
        for msg_id, data in bot._processed_messages.items():
            msg_time = data.get('timestamp', 0)
            if current_time - msg_time < 60:  # Last minute
                recent_messages[msg_id] = data
                
        # Get the 10 most recent messages for inspection
        recent_entries = sorted(
            [(msg_id, data.get('timestamp', 0)) for msg_id, data in bot._processed_messages.items()],
            key=lambda x: x[1],
            reverse=True
        )[:10]
        
        recent_details = []
        for msg_id, _ in recent_entries:
            data = bot._processed_messages[msg_id]
            recent_details.append({
                "id": msg_id,
                "time": datetime.fromtimestamp(data.get('timestamp', 0)).isoformat(),
                "pid": data.get('pid', 'unknown'),
                "command": data.get('command', None)
            })
        
        status["processed_messages"] = {
            "total_count": len(bot._processed_messages),
            "recent_count": len(recent_messages),
            "recent_samples": recent_details
        }
    
    # Add lock file information
    lock_files = [f for f in os.listdir('.') if f.startswith('message_') and f.endswith('.lock')]
    status["lock_files"] = {
        "count": len(lock_files),
        "samples": lock_files[:5] if lock_files else []
    }
    
    # Check for the cache file
    status["cache_file"] = {
        "exists": os.path.exists("processed_messages_cache.json"),
        "size": os.path.getsize("processed_messages_cache.json") if os.path.exists("processed_messages_cache.json") else 0,
        "modified": datetime.fromtimestamp(os.path.getmtime("processed_messages_cache.json")).isoformat() if os.path.exists("processed_messages_cache.json") else None
    }
    
    return jsonify(status)

@app.route('/restart', methods=['POST'])
def restart_bot_endpoint():
    """Endpoint to restart the bot"""
    try:
        # Signal a restart
        if bot is not None:
            asyncio.create_task(bot.close())
        return jsonify({"status": "restarting", "message": "Bot restart initiated"})
    except Exception as e:
        return jsonify({"status": "error", "message": f"Failed to restart: {str(e)}"}), 500

@app.route('/test_spill')
def test_spill():
    """Test the spill command with debug logging"""
    logging.info("Testing spill command via web route")
    
    # Get a guild
    guild = None
    for g in bot.guilds:
        guild = g
        break
        
    if not guild:
        return "No guilds found"
    
    # Generate a spill response directly from the player drama generator
    try:
        from player_drama import PlayerDramaGenerator
        
        # Log all member values for debugging
        all_values = data_manager.get_all_member_values()
        if all_values:
            # Log top 5 highest value players for debugging
            sorted_members = sorted(all_values.items(), key=lambda x: x[1], reverse=True)
            top_5 = sorted_members[:5]
            top_players = ', '.join([f'{member_id}: {value}' for member_id, value in top_5])
            logging.info(f"Top 5 highest value players: {top_players}")
            
        # Generate drama without joke reaction tracking
        drama_generator = PlayerDramaGenerator(data_manager)
        logging.info(f"Generating drama for server {guild.id} with high-value threshold {drama_generator.high_value_threshold}")
        drama_scenario = drama_generator.generate_drama(guild)
        
        return f"<h1>Test Spill Command</h1><p>{drama_scenario}</p>"
    except Exception as e:
        logging.error(f"Error generating player drama: {e}", exc_info=True)
        return f"<h1>Error</h1><p>Failed to generate drama: {str(e)}</p>"

@app.route('/cron')
def cron_endpoint():
    """Cron-friendly endpoint that will restart the bot if it's not running
    This endpoint is designed to be called by a cron job every few minutes.
    If the bot is down, it will automatically restart it.
    """
    # Get heartbeat age for accurate health check
    last_heartbeat_age = time.time() - last_heartbeat if 'last_heartbeat' in globals() else 9999
    
    # Determine if the bot is actually healthy based on connection AND heartbeat
    is_healthy = False
    
    # Check if bot is connected and has a recent heartbeat
    if bot is not None and bot.is_ready() and last_heartbeat_age < 120:
        is_healthy = True
        uptime = int(time.time() - start_time)
    else:
        uptime = None
        
    # Log the health check
    logger.info(f"Cron health check: Connected={bot is not None and bot.is_ready()}, Heartbeat age={int(last_heartbeat_age)}s, Healthy={is_healthy}")
    
    # If not healthy, trigger a restart
    if not is_healthy:
        try:
            logging.warning("Cron endpoint detected unhealthy bot - triggering restart")
            
            # Run restart in a non-blocking way
            def restart_thread():
                try:
                    # Close bot connection if exists
                    if bot is not None:
                        asyncio.run_coroutine_threadsafe(bot.close(), bot.loop)
                    
                    # Wait a bit for cleanup
                    time.sleep(5)
                    
                    # Remove lock files
                    for lock_file in ["bot.lock", "auto_401_recovery.pid", "401_recovery_startup.lock"]:
                        if os.path.exists(lock_file):
                            os.remove(lock_file)
                    
                    # Restart the bot
                    os.execv(sys.executable, [sys.executable] + sys.argv)
                except Exception as e:
                    logging.error(f"Failed in restart thread: {e}")
            
            # Start restart in background
            threading.Thread(target=restart_thread, daemon=True).start()
            
            return jsonify({
                "status": "restarting",
                "message": "Bot was down - restart initiated"
            })
        except Exception as e:
            logging.error(f"Error restarting bot from cron endpoint: {e}")
            return jsonify({
                "status": "error",
                "message": f"Failed to restart bot: {str(e)}"
            }), 500
    
    # Bot is healthy
    return jsonify({
        "status": "ok",
        "bot_connected": True,
        "uptime": uptime
    })

def run_webserver():
    app.run(host="0.0.0.0", port=5001, debug=False)

def keep_alive():
    """Start the Flask server in a separate thread"""
    def run():
        app.run(host='0.0.0.0', port=5001)  # Use port 5001 for the bot's internal server
    thread = threading.Thread(target=run)
    thread.daemon = True
    thread.start()

# =============================
# SINGLE INSTANCE CHECK & CLEANUP
# =============================
# Use centralized instance management constants
# For backward compatibility
LOCK_FILE = BOT_PID_FILE
PID_FILE = BOT_PID_FILE

def remove_lock_files():
    """Remove bot lock files with safety checks to prevent removing active locks"""
    current_pid = os.getpid()
    
    for file in [LOCK_FILE, PID_FILE]:
        if os.path.exists(file):
            try:
                # First check if this is a PID file
                with open(file, 'r') as f:
                    content = f.read().strip()
                    # Attempt to parse as PID (if it's a number)
                    if content.isdigit():
                        file_pid = int(content)
                        
                        # Only remove if it's our PID or if the process is not running
                        if file_pid == current_pid:
                            logger.info(f"Removing our own lock file {file} with PID {file_pid}")
                            os.remove(file)
                        else:
                            try:
                                # Check if the process exists
                                os.kill(file_pid, 0)
                                logger.warning(f"Lock file {file} with PID {file_pid} belongs to a running process, not removing (our PID: {current_pid})")
                            except OSError:
                                # Process doesn't exist, safe to remove
                                logger.info(f"Removing stale lock file {file} with PID {file_pid}")
                                os.remove(file)
                    else:
                        # Not a PID file or invalid content, safe to remove
                        logger.info(f"Removing lock file {file} with non-PID content")
                        os.remove(file)
            except Exception as e:
                # If we can't read the file or any other error, better to keep it
                logger.error(f"Error processing lock file {file}: {e}")
                # Only forcibly remove if specifically instructed by command line flag
                if "--force-remove-locks" in sys.argv:
                    try:
                        os.remove(file)
                        logger.warning(f"Forcibly removed lock file {file} due to --force-remove-locks flag")
                    except Exception as e2:
                        logger.error(f"Failed to forcibly remove {file}: {e2}")

# =============================
# LOGGING CONFIGURATION
# =============================
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[logging.StreamHandler(), logging.FileHandler("bot.log")]
)
logger = logging.getLogger(__name__)

# =============================
# BOT INITIALIZATION & GLOBALS
# =============================
# Setup intents - all configuration must happen before bot creation
def configure_intents():
    try:
        intents = discord.Intents.default()
        # Required intents for core functionality
        required_intents = {
            'message_content': True,  # For message content access
            'members': True,          # For member events
            'reactions': True,        # For reaction tracking
            'guilds': True,           # For server information
            'guild_messages': True,   # For server messages
            'dm_messages': True,      # For DM functionality
            'guild_reactions': True   # For reaction tracking
        }
        
        # Apply all required intents
        for intent_name, value in required_intents.items():
            setattr(intents, intent_name, value)
            
        logger.info(f"Bot intents configured successfully: {', '.join(f'{k}={v}' for k,v in required_intents.items())}")
        return intents
        
    except Exception as intent_error:
        logger.critical(f"Critical error setting up intents: {intent_error}")
        raise  # Re-raise to prevent bot from starting with incorrect intents

# Configure intents BEFORE creating the bot
intents = discord.Intents.default()
intents.message_content = True
intents.members = True
intents.reactions = True
intents.guilds = True
intents.guild_messages = True
intents.dm_messages = True
intents.guild_reactions = True

# Create bot with validated intents and slash command support
class NovaBot(commands.Bot):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.command_tree = self.tree  # Keep a reference to the command tree for syncing

    async def setup_hook(self):
        logger.info("Setting up slash commands...")
        try:
            from timeout_handlers import safe_task, wrap_all_async_operations
            # Enhance critical bot methods with proper task context handling
            wrap_all_async_operations(self)
            logger.info("Enhanced bot methods with proper task context handling")
        except Exception as wrapper_err:
            logger.warning(f"Task context enhancement failed: {wrapper_err}")
        await super().setup_hook()

# Create bot with configured intents (DO NOT modify intents later)
bot = NovaBot(command_prefix=COMMAND_PREFIX, intents=intents, case_insensitive=True)
logger.info(f"Bot created successfully with prefix: {COMMAND_PREFIX}")

# Initialize other components
data_manager = DataManager(DATA_FILE)
activity_tracker = ActivityTracker(data_manager)
logger.setLevel(logging.DEBUG)
logger.debug(f"Bot initialization with process ID: {os.getpid()}")

# Attach data_manager to bot to avoid circular imports
bot.data_manager = data_manager

# Enhanced on_ready event handler with reliability features
@bot.event
async def on_ready():
    """
    Ultra-reliable on_ready event handler with comprehensive uptime tracking
    - Maintains connection state across disconnections and reconnections
    - Provides detailed logging for debugging connection issues
    - Implements proactive health checking and recovery
    - Records performance metrics for long-term reliability analysis
    - Ensures state consistency with automatic data reloading
    """
    try:
        # Initialize bot state variables if this is first connection
        if not hasattr(bot, 'start_time') or bot.start_time is None:
            # Initial connection
            bot.start_time = datetime.now()
            bot.reconnection_count = 0
            bot.last_reconnection_time = None
            bot.connection_history = []
            bot.healthy = True
            bot.last_heartbeat = datetime.now()
            bot.connection_issues = 0
            bot.last_connection_issue = None
            bot.last_successful_operation = datetime.now()
            bot.ops_since_reconnect = 0
            
            # Try to start the heartbeat task - properly handle if already running
            try:
                if not hasattr(update_heartbeat, 'is_running') or not update_heartbeat.is_running():
                    update_heartbeat.start()
                    logger.info("Started heartbeat monitoring task")
            except Exception as task_err:
                logger.error(f"Error starting heartbeat task: {task_err}")
                # Create a backup heartbeat mechanism using a background task
                bot.loop.create_task(backup_heartbeat_monitor())
            
            logger.info(f"Bot startup complete - Connected as {bot.user} (ID: {bot.user.id})")
        
        # Initialize slash commands
        try:
            import slash_commands
            slash_commands.setup_slash_commands(bot, data_manager)
            logger.info("Initialized slash commands successfully")
            
            # Only sync commands in first-time startup to avoid rate limits
            if not hasattr(bot, 'slash_commands_synced') or not bot.slash_commands_synced:
                await bot.tree.sync()
                bot.slash_commands_synced = True
                logger.info("Slash commands synced with Discord")
        except Exception as e:
            logger.error(f"Error setting up slash commands: {e}", exc_info=True)
            
        # Initialize command suggestion system
        try:
            # Import the command suggestion system
            import command_suggestions
            suggestion_system = command_suggestions.CommandSuggestionSystem(bot, COMMAND_PREFIX)
            suggestion_system.register_with_bot()
            logger.info(f"Command suggestion system initialized with prefix: {COMMAND_PREFIX}")
        except Exception as e:
            logger.error(f"Error setting up command suggestion system: {e}", exc_info=True)
        else:
            # This is a reconnection event - record it with timestamp
            bot.reconnection_count += 1
            reconnect_time = datetime.now()
            bot.last_reconnection_time = reconnect_time
            
            # Calculate downtime if possible
            downtime = None
            if bot.last_heartbeat:
                downtime = (reconnect_time - bot.last_heartbeat).total_seconds()
                
            # Store in connection history (keep last 20 events)
            bot.connection_history.append({
                'event': 'reconnect',
                'count': bot.reconnection_count,
                'timestamp': reconnect_time.isoformat(),
                'downtime_seconds': downtime
            })
            if len(bot.connection_history) > 20:
                bot.connection_history = bot.connection_history[-20:]
            
            # Restart heartbeat task if it died
            try:
                if not update_heartbeat.is_running():
                    logger.warning("Heartbeat task not running, restarting it")
                    try:
                        update_heartbeat.restart()
                    except Exception:
                        update_heartbeat.start()
            except Exception as task_err:
                logger.error(f"Error restarting heartbeat task: {task_err}")
                # Create a backup heartbeat mechanism
                bot.loop.create_task(backup_heartbeat_monitor())
                
            logger.info(f"Bot reconnected (#{bot.reconnection_count}) - Connected as {bot.user} (ID: {bot.user.id})")
            
            if downtime:
                logger.info(f"Approximate downtime: {downtime:.1f} seconds")
    
        # Record connected servers with detailed information
        connected_servers = []
        for guild in bot.guilds:
            try:
                guild_info = f"{guild.name} (ID: {guild.id}, Members: {guild.member_count})"
                connected_servers.append(guild_info)
            except Exception as guild_err:
                logger.error(f"Error processing guild info: {guild_err}")
                connected_servers.append(f"Unknown Guild (ID: {guild.id})")
                
        logger.info(f"Connected to {len(bot.guilds)} servers: {', '.join(connected_servers)}")
        
        # Set bot activity status with error handling
        try:
            activity_status = discord.Activity(type=discord.ActivityType.watching, name="over Novera with love ðŸ’–")
            await bot.change_presence(activity=activity_status, status=discord.Status.online)
            logger.info(f"Set bot activity status: {activity_status.name}")
        except Exception as status_err:
            logger.error(f"Failed to set activity status: {status_err}")
        
        # Mark the bot as healthy and record heartbeat
        bot.healthy = True
        bot.last_heartbeat = datetime.now()
        bot.last_successful_operation = datetime.now()
        
        # Initialize/reset counters
        if not hasattr(bot, 'message_count'):
            bot.message_count = 0
            bot.command_count = 0
            bot.error_count = 0
        
        # Reload the data to ensure consistency
        try:
            data_manager._load_data()
            logger.info("Successfully reloaded data from disk on bot ready")
        except Exception as data_err:
            logger.error(f"Failed to reload data on bot ready: {data_err}")
            # Try a more aggressive data recovery
            try:
                # If we have backups, try to restore from them
                data_manager._restore_from_backup()
                logger.warning("Attempted recovery from backup after data load failure")
            except Exception as backup_err:
                logger.error(f"Backup recovery also failed: {backup_err}")
    except Exception as e:
        logger.critical(f"Critical error in on_ready handler: {e}", exc_info=True)

# Backup heartbeat mechanism in case the task system fails
async def backup_heartbeat_monitor():
    """Backup heartbeat monitor that runs as a regular async task if the tasks.loop fails"""
    logger.warning("Started backup heartbeat monitor - this indicates a potential issue with the primary monitor")
    while True:
        try:
            # Wait for 30 seconds between heartbeats
            await asyncio.sleep(30)
            
            # Update heartbeat timestamp
            bot.last_heartbeat = datetime.now()
            
            # Log status every 5 minutes (10 cycles)
            if random.randint(1, 10) == 1:  # Random to prevent all logging at exactly the same time
                uptime = int((datetime.now() - bot.start_time).total_seconds())
                logger.info(f"[BACKUP] Bot heartbeat: Uptime {uptime}s, Reconnections: {bot.reconnection_count}")
        except Exception as e:
            logger.error(f"Error in backup heartbeat: {e}")
            await asyncio.sleep(5)  # Short delay before retrying

# Primary heartbeat task to track bot health
@tasks.loop(seconds=30)
async def update_heartbeat():
    """Update the bot's heartbeat timestamp to track health and monitor for issues"""
    try:
        current_time = datetime.now()
        bot.last_heartbeat = current_time
        
        # Check for task gap - detect if heartbeats are being missed
        if hasattr(update_heartbeat, 'last_run'):
            gap = (current_time - update_heartbeat.last_run).total_seconds()
            if gap > 60:  # Over twice the expected interval
                logger.warning(f"Heartbeat task delayed by {gap:.1f}s - possible performance issue")
                
        # Store last run time
        update_heartbeat.last_run = current_time
        
        # Periodically log bot state
        if update_heartbeat.current_loop % 5 == 0 and update_heartbeat.current_loop > 0:
            # Calculate uptime
            uptime_seconds = int((current_time - bot.start_time).total_seconds())
            uptime_formatted = f"{uptime_seconds // 86400}d {(uptime_seconds % 86400) // 3600}h {(uptime_seconds % 3600) // 60}m {uptime_seconds % 60}s"
            
            # Get message stats
            msg_count = getattr(bot, 'message_count', 0)
            cmd_count = getattr(bot, 'command_count', 0)
            error_count = getattr(bot, 'error_count', 0)
            
            # Log comprehensive status
            logger.info(
                f"Bot heartbeat: Uptime {uptime_formatted}, "
                f"Reconnections: {bot.reconnection_count}, "
                f"Messages: {msg_count}, Commands: {cmd_count}, Errors: {error_count}"
            )
            
            # Check memory usage periodically
            try:
                process = psutil.Process(os.getpid())
                memory_usage = process.memory_info().rss / 1024 / 1024  # in MB
                logger.info(f"Memory usage: {memory_usage:.1f} MB")
                
                # Log warning if memory usage is high
                if memory_usage > 500:  # 500 MB threshold
                    logger.warning(f"High memory usage detected: {memory_usage:.1f} MB")
            except Exception as mem_err:
                logger.error(f"Error checking memory usage: {mem_err}")
                
    except Exception as e:
        logger.error(f"Error in heartbeat task: {e}", exc_info=True)
        
        # Increment error counter
        bot.error_count = getattr(bot, 'error_count', 0) + 1
        
        # If heartbeat fails repeatedly, try to restart the task
        try:
            if hasattr(bot, 'heartbeat_errors'):
                bot.heartbeat_errors += 1
                if bot.heartbeat_errors > 5:
                    logger.warning("Multiple heartbeat errors, attempting to restart task")
                    update_heartbeat.restart()
                    bot.heartbeat_errors = 0
            else:
                bot.heartbeat_errors = 1
        except Exception as restart_err:
            logger.error(f"Failed to restart heartbeat after errors: {restart_err}")

# Error handler for heartbeat task
@update_heartbeat.error
async def heartbeat_error(error):
    """Handle errors in the heartbeat task"""
    logger.error(f"Heartbeat task failed with error: {error}", exc_info=True)
    try:
        # Try to restart the task
        if update_heartbeat.is_running():
            update_heartbeat.restart()
            logger.info("Heartbeat task restarted after error")
        else:
            update_heartbeat.start()
            logger.info("Heartbeat task started after error")
    except Exception as e:
        logger.critical(f"Failed to restart heartbeat task: {e}")
        # Fall back to the backup heartbeat monitor
        bot.loop.create_task(backup_heartbeat_monitor())

# =============================
# UTILITY FUNCTION TO CHECK MANAGEMENT ROLES
# =============================
def has_management_role(member: discord.Member) -> bool:
    """Check if a member has a management role using server-specific configuration"""
    from server_config import get_role_ids
    
    # Get management role IDs for this server
    server_id = str(member.guild.id)
    management_role_ids = get_role_ids("management", server_id)
    
    # Convert member roles to strings for comparison
    member_role_ids = [str(role.id) for role in member.roles]
    
    # Check if any management roles match member roles
    for role_id in management_role_ids:
        if role_id in member_role_ids:
            logger.debug(f"Management permission granted to {member.name} (ID: {member.id}) in server {server_id}")
            return True
    
    logger.debug(f"Management permission denied for {member.name} (ID: {member.id}) in server {server_id}")
    return False

# =============================
# UTILITY CLASSES
# =============================
class PlayerEvaluation:
    def __init__(self, ratings: dict, feedback: str, is_goalkeeper: bool, position_name: str = None):
        self.ratings = ratings
        self.feedback = feedback
        self.is_goalkeeper = is_goalkeeper
        self.position_name = position_name

    def calculate_value(self) -> int:
        """Calculate player value based on ratings
        - All 5s should result in 12 million
        - All 10s should result in 24 million
        """
        try:
            if self.is_goalkeeper:
                weights = {
                    'goalkeeping': 3.5,
                    'passing': 1.5,
                    'shooting': 0.33,
                    'dribbling': 0.33,
                    'defense': 0.33
                }
            else:
                weights = {
                    'shooting': 2.5,
                    'passing': 1.0,
                    'dribbling': 1.5,
                    'defense': 1.0,
                    'goalkeeping': 0.5
                }
            
            base_value = 0
            max_points = 0
            for skill, weight in weights.items():
                rating = self.ratings.get(skill)
                if rating is not None:
                    base_value += rating * weight
                    max_points += 10 * weight
            
            # Calculate percentage of potential (0.0 to 1.0)
            if max_points > 0:
                performance_ratio = base_value / max_points
                
                # Scale to make 50% (all 5s) equal to 12 million
                # and 100% (all 10s) equal to 24 million
                return int(performance_ratio * 24)
            return 0
        except Exception as e:
            logger.error(f"Error calculating value: {e}", exc_info=True)
            return 0

class MatchType:
    ONETWOONE = 1   # 1v1
    TWOVTWO = 2     # 2v2
    THREEVTHREE = 3 # 3v3
    FIVEVFIVE = 5   # 5v5

class MatchState:
    def __init__(self, creator: discord.Member):
        self.creator = creator
        self.guild = creator.guild
        self.match_type: Optional[int] = None
        self.amount: Optional[int] = None
        self.allow_abilities: Optional[bool] = None
        self.region: Optional[str] = None
        self.roblox_username: Optional[str] = None
        self.private_server: Optional[str] = None
        self.team1: List[discord.Member] = []
        self.team2: List[discord.Member] = []
        self.current_step = 0
        self.creation_message: Optional[discord.Message] = None
        self.status = "creating"

    def is_full(self) -> bool:
        return len(self.team1) >= self.match_type and len(self.team2) >= self.match_type

    def add_player(self, player: discord.Member, team_num: int):
        if team_num == 1 and player not in self.team1:
            self.team1.append(player)
            logger.info(f"Added {player.id} to Team 1")
        elif team_num == 2 and player not in self.team2:
            self.team2.append(player)
            logger.info(f"Added {player.id} to Team 2")

# =============================
# MATCH CREATION FLOW - PROCESS DM STEPS
# =============================
async def process_match_creation_step(match_state: MatchState, message: discord.Message):
    content = message.content.strip()
    if match_state.current_step == 0:
        if content not in ['1', '2', '3', '5']:
            await message.channel.send("âŒ Oh dear, darling, please choose a valid match type: 1, 2, 3, or 5! Mommy needs your proper input, sweetie! ðŸ˜‡")
            return
        match_state.match_type = int(content)
        match_state.current_step += 1
        await message.channel.send("ðŸ’° Alright, sweetie, now please enter your wager amount (minimum 5m) so Mommy knows your stake! ðŸ’¸")
    elif match_state.current_step == 1:
        try:
            wager = int(content)
            if wager < 5:
                await message.channel.send("âŒ Oh my, the minimum wager is 5m, darling! Please enter a valid amount for Mommy! ðŸ’–")
                return
            match_state.amount = wager
            match_state.current_step += 1
            await message.channel.send("âœ¨ Now, darling, do you want to allow abilities in this match? Please type 'yes' or 'no'! ðŸ’«")
        except ValueError:
            await message.channel.send("âŒ Oopsie, darling! Please enter a proper number for your wager amount! ðŸ”¢")
    elif match_state.current_step == 2:
        if content.lower() not in ['yes', 'no']:
            await message.channel.send("âŒ Oh dear, sweetie, please answer 'yes' or 'no' for allowing abilities! ðŸ™")
            return
        match_state.allow_abilities = True if content.lower() == 'yes' else False
        match_state.current_step += 1
        await message.channel.send("ðŸŒ Now, sweetie, please select your region: Type 'NA' for North America or 'EU' for Europe! ðŸŒŽ")
    elif match_state.current_step == 3:
        if content.upper() not in ['NA', 'EU']:
            await message.channel.send("âŒ Oh dear, please type 'NA' or 'EU' for the region, sweetie! ðŸ™")
            return
        match_state.region = content.upper()
        match_state.current_step += 1
        await message.channel.send("ðŸ‘¤ Lovely, now please enter your Roblox username, darling! ðŸ¤©")
    elif match_state.current_step == 4:
        if not content:
            await message.channel.send("âŒ Oh no, sweetie! Please provide a valid Roblox username for Mommy! ðŸ˜¢")
            return
        match_state.roblox_username = content
        match_state.current_step += 1
        await message.channel.send("ðŸ”— Great, darling! Do you have a private server link? Type 'skip' to skip or paste your link, sweetie! ðŸ“Ž")
    elif match_state.current_step == 5:
        try:
            if content.lower() == "skip":
                match_state.private_server = None
            else:
                match_state.private_server = content
            match_state.current_step += 1
            
            # Get the correct channel based on match type
            channel_mapping = {
                1: "âš”-1v1-duels",
                2: "ðŸ¤-2v2-battles",
                3: "ðŸ’¨-3v3-showdowns",
                5: "ðŸ†-5v5-warzone"
            }
            channel_name = channel_mapping.get(match_state.match_type)
            
            # Safety check - make sure guild is available
            if not match_state.guild:
                logger.error(f"Guild not available for match creation by {message.author.id}")
                await message.channel.send("âŒ Oh no sweetie, Mommy couldn't find the server! Please try again later or contact staff. ðŸ’”")
                if message.author.id in active_matches:
                    del active_matches[message.author.id]
                return
                
            ad_channel = discord.utils.get(match_state.guild.text_channels, name=channel_name)
            if not ad_channel:
                logger.error(f"Could not find match advertisement channel '{channel_name}' for {message.author.id}")
                await message.channel.send("âŒ Oh dear, Mommy couldn't find the match advertisement channel! Please contact the staff, sweetie! ðŸ“ž")
                if message.author.id in active_matches:
                    del active_matches[message.author.id]
                return
                
            # Create the match embed
            embed = discord.Embed(
                title="ðŸŽ® New Match Available!",
                description=(
                    f"**Match Type:** {match_state.match_type}v{match_state.match_type}\n"
                    f"**Wager:** Â¥{match_state.amount}m\n"
                    f"**Allow Abilities:** {'Yes' if match_state.allow_abilities else 'No'}\n"
                    f"**Region:** {match_state.region}\n"
                    f"**Roblox Username:** {match_state.roblox_username}"
                ),
                color=discord.Color.blue()
            )
            
            # Add private server if provided
            if match_state.private_server:
                embed.add_field(name="ðŸ”— Private Server", value=match_state.private_server, inline=False)
                
            # Post advertisement and add reactions
            ad_message = await ad_channel.send(embed=embed)
            match_state.creation_message = ad_message
            
            # Add appropriate reactions based on match type
            if match_state.match_type == 1:
                await ad_message.add_reaction("2ï¸âƒ£")
            else:
                await ad_message.add_reaction("1ï¸âƒ£")
                await ad_message.add_reaction("2ï¸âƒ£")
                
            # Add creator to team 1
            match_state.team1.append(match_state.creator)
            
            # Send success message
            await message.channel.send("âœ… Darling, your match has been created! Check the ad channel for the juicy details!")
            
            # Clean up active matches and store match state by advertisement
            if message.author.id in active_matches:
                del active_matches[message.author.id]
            active_matches_by_ad[ad_message.id] = match_state
            
            # Add debug logging
            logger.info(f"Match created successfully by {message.author.id} - Type: {match_state.match_type}v{match_state.match_type}, Wager: {match_state.amount}m")
            
        except Exception as e:
            # Enhanced error handling
            logger.error(f"Error finalizing match creation for {message.author.id}: {str(e)}", exc_info=True)
            await message.channel.send("âŒ Oh no sweetie, Mommy couldn't create your match due to a technical issue! Please try again or contact staff. ðŸ’”")
            # Clean up failed match creation
            if message.author.id in active_matches:
                del active_matches[message.author.id]
    else:
        await message.channel.send("âŒ Oh no, a little boo boo occurred in match creation. Please try again, sweetie! ðŸ˜­")

# =============================
# ON_REACTION_ADD EVENT HANDLER
# =============================
@bot.event
async def on_reaction_add(reaction, user):
    # Update last heartbeat on every reaction received
    global last_heartbeat
    last_heartbeat = time.time()
    
    if user.bot:
        return
    message = reaction.message
    
    # Process joke reactions for adaptive joke selection
    try:
        from joke_reactions import process_reaction
        await process_reaction(reaction, user)
    except Exception as e:
        logger.error(f"Error processing joke reaction: {e}", exc_info=True)
    
    # Process match advertisements
    if message.id in active_matches_by_ad:
        match_state = active_matches_by_ad[message.id]
        if match_state.match_type == 1:
            if str(reaction.emoji) == "2ï¸âƒ£":
                if user in match_state.team1 or user in match_state.team2:
                    return
                if len(match_state.team2) >= match_state.match_type:
                    return
                match_state.team2.append(user)
                await message.channel.send(f"ðŸ’– Oh sweetie, {user.mention}, you've joined Team 2! Mommy is so proud of you! âœ¨")
        else:
            if str(reaction.emoji) == "1ï¸âƒ£":
                if user in match_state.team1 or user in match_state.team2:
                    return
                if len(match_state.team1) >= match_state.match_type:
                    return
                match_state.team1.append(user)
                await message.channel.send(f"ðŸ’– Oh darling, {user.mention}, you've joined Team 1! Shine on, sweetie! ðŸŒŸ")
            elif str(reaction.emoji) == "2ï¸âƒ£":
                if user in match_state.team1 or user in match_state.team2:
                    return
                if len(match_state.team2) >= match_state.match_type:
                    return
                match_state.team2.append(user)
                await message.channel.send(f"ðŸ’– Oh precious, {user.mention}, you've joined Team 2! Keep sparkling! âœ¨")
        if match_state.is_full():
            details = (
                f"**Match Details:**\n"
                f"Match Type: {match_state.match_type}v{match_state.match_type}\n"
                f"Wager: Â¥{match_state.amount} million\n"
                f"Region: {match_state.region}\n"
            )
            host_info = (
                f"**Host Info:**\n"
                f"Discord: {match_state.creator.mention}\n"
                f"Roblox: {match_state.roblox_username}\n"
            )
            if match_state.private_server:
                host_info += f"Private Server: {match_state.private_server}\n"
            teams_text = (
                f"**Team Composition:**\n"
                f"Team 1: {', '.join([m.mention for m in match_state.team1])}\n"
                f"Team 2: {', '.join([m.mention for m in match_state.team2])}\n"
            )
            full_message = (
                f"ðŸ’Œ Hello, my gorgeous Novarian! Your match is set and sizzling hot! ðŸ”¥\n\n"
                f"{details}\n"
                f"{host_info}\n"
                f"{teams_text}\n\n"
                f"*after adding the host on roblox, click the ðŸ“© reaction below to request to be added on roblox*"
            )
            for participant in match_state.team1 + match_state.team2:
                if participant.id == match_state.creator.id:
                    continue
                try:
                    dm_channel = await participant.create_dm()
                    dm_msg = await dm_channel.send(full_message)
                    await dm_msg.add_reaction("ðŸ“©")
                    pending_join_requests[dm_msg.id] = {"match_state": match_state, "participant": participant}
                except Exception as e:
                    logger.error(f"Error sending DM to {participant.id}: {e}", exc_info=True)
            try:
                await message.delete()
            except Exception as e:
                logger.error(f"Error deleting match ad: {e}", exc_info=True)
            await message.channel.send(
                "âœ¨ Oh, my dazzling Novarians, your match is set and steamy! Check your DMs for all the juicy details, and once you're done, use `!matchresults` to report your result. Mommy can't wait to hear all about it! ðŸ’–"
            )
            pending_results[match_state.creator.id] = match_state
            del active_matches_by_ad[message.id]
    elif message.id in pending_join_requests:
        if str(reaction.emoji) == "ðŸ“©":
            info = pending_join_requests[message.id]
            match_state = info["match_state"]
            participant = info["participant"]
            host = match_state.creator
            try:
                dm_host = await host.create_dm()
                await dm_host.send(
                    f"ðŸ’Œ Oh my, {host.mention}! {participant.mention} is asking to be added on Roblox to join your match! Please check them out, sweetie! ðŸŒ¸"
                )
            except Exception as e:
                logger.error(f"Error sending join request DM to host {host.id}: {e}", exc_info=True)
            del pending_join_requests[message.id]

# =============================
# ON_MEMBER_REMOVE EVENT HANDLER (LEAVING MESSAGE)
# =============================
@bot.event
async def on_member_remove(member):
    # Update last heartbeat on every member remove event
    global last_heartbeat
    last_heartbeat = time.time()
    try:
        # Get server-specific configuration
        from server_config import get_channel_id, get_server_setting, get_server_name
        
        # Import leaving messages from separate module
        from leaving_messages import LEAVING_MESSAGES
        
        server_id = str(member.guild.id)
        logger.info(f"Member {member.id} left server {server_id}")
        
        # Get the server name for customized messages
        server_name = get_server_name(server_id) or "Novera"
        
        # Check if this server should announce member leaves
        announce_leaves = get_server_setting("announce_leaves", server_id)
        if announce_leaves is False:
            logger.info(f"Server {server_id} is configured to not announce member leaves")
            return
            
        # Get the welcome/goodbye channel for this server
        welcome_channel = None
        welcome_channel_id = get_channel_id("welcome", server_id)
        
        if welcome_channel_id and welcome_channel_id.isdigit():
            # If it's an ID, get the channel by ID
            welcome_channel = member.guild.get_channel(int(welcome_channel_id))
        else:
            # Try to find by name if not found by ID
            welcome_channel = discord.utils.get(member.guild.text_channels, name="welcome-to-novera")
        
        if welcome_channel:
            # Use the leaving messages from the imported module
            if LEAVING_MESSAGES:
                # Use the dedicated leaving messages
                leave_msg = random.choice(LEAVING_MESSAGES).format(member_mention=member.mention, server_name=server_name)
            else:
                # Fallback messages if the import somehow failed
                leave_messages = [
                    f"ðŸ˜¢ Oh no! {member.mention} has left the {server_name} family! Mommy will miss you, sweetie! ðŸ’”",
                    f"ðŸ‘‹ Farewell, {member.mention}! Mommy hopes you'll come back to {server_name} soon, darling! ðŸŒˆ",
                    f"ðŸ’­ {member.mention} has departed from {server_name}... Mommy's heart aches a little! ðŸ’”",
                    f"ðŸ”® The stars of {server_name} shine a little less bright without you, {member.mention}! ðŸ’«"
                ]
                leave_msg = random.choice(leave_messages)
            
            await welcome_channel.send(leave_msg)
            logger.info(f"Sent leaving message for {member.id} in server {server_id}")
        else:
            logger.warning(f"Welcome channel not found for server {server_id}")
    except Exception as e:
        logger.error(f"Error in on_member_remove: {e}", exc_info=True)

# =============================
# ANTEUP COMMAND
# =============================
@bot.command(name='anteup')
async def anteup_cmd(ctx):
    try:
        logger.info(f"Anteup command received from {ctx.author.id}")
        if ctx.author.id in active_matches:
            await ctx.send("âŒ Oh dear, you already have an active match creation! Please cancel it first, sweetie! ðŸ™…")
            return
        try:
            dm_channel = await ctx.author.create_dm()
            logger.info(f"Created DM channel for {ctx.author.id}")
        except discord.Forbidden:
            logger.error(f"Could not create DM channel for {ctx.author.id}")
            await ctx.send("âŒ Oops, I couldn't send you a DM! Please enable your DMs and try again, darling! ðŸ’Œ")
            return
        match_state = MatchState(ctx.author)
        active_matches[ctx.author.id] = match_state
        await ctx.send("ðŸ“© Sweetheart, check your DMs to set up your match!")
        await dm_channel.send(
            "**ðŸŽ® Let's Ante Up!**\n"
            "Mommy wants to see you shine, darling!\n\n"
            "**Choose Your Match Type:**\n"
            "> `1` for 1v1\n"
            "> `2` for 2v2\n"
            "> `3` for 3v3\n"
            "> `5` for 5v5\n"
            "Enter the number for your choice, sweetie! ðŸ’¡"
        )
        logger.info(f"Match creation (anteup) initiated for {ctx.author.id}")
    except Exception as e:
        logger.error(f"Error in anteup command: {e}", exc_info=True)
        await ctx.send(random.choice(MOMMY_ERROR_VARIANTS))

# =============================
# MATCHCANCEL COMMAND
# =============================
@bot.command(name='matchcancel')
async def match_cancel(ctx):
    try:
        canceled = False
        cancel_message = ""
        
        # Check if there's an active match being created
        if ctx.author.id in active_matches:
            match_state = active_matches[ctx.author.id]
            
            # If there's an ad message, delete it and clean up active_matches_by_ad
            if match_state.creation_message:
                try:
                    # Remove from active_matches_by_ad if it exists there
                    ad_id = match_state.creation_message.id
                    if ad_id in active_matches_by_ad:
                        del active_matches_by_ad[ad_id]
                        logger.info(f"Removed match from active_matches_by_ad for message {ad_id}")
                    
                    # Delete the advertisement message
                    await match_state.creation_message.delete()
                    logger.info(f"Deleted match advertisement message {ad_id}")
                except Exception as e:
                    logger.error(f"Error deleting match ad message: {e}", exc_info=True)
                    cancel_message = "ðŸ§¡ Mommy tried to delete your match advertisement, but couldn't find it. It might have been deleted already, sweetie!"
            
            # Remove from active_matches
            del active_matches[ctx.author.id]
            canceled = True
            if not cancel_message:
                cancel_message = "âœ… Darling, your match has been cancelled! " + random.choice(MOMMY_SUCCESS_VARIANTS)
        
        # If not found in active_matches, check all active_matches_by_ad
        if not canceled:
            # Find any match ads created by this user
            creator_ads = []
            for ad_id, match_state in list(active_matches_by_ad.items()):
                if match_state.creator.id == ctx.author.id:
                    creator_ads.append((ad_id, match_state))
            
            # If found, delete them
            if creator_ads:
                for ad_id, match_state in creator_ads:
                    try:
                        # Get the channel the ad was posted in
                        channel = match_state.creation_message.channel if match_state.creation_message else None
                        
                        # Try to delete the message
                        if channel and match_state.creation_message:
                            await match_state.creation_message.delete()
                            logger.info(f"Deleted match advertisement message {ad_id}")
                    except Exception as e:
                        logger.error(f"Error deleting match ad message from active_matches_by_ad: {e}", exc_info=True)
                    
                    # Remove from the dictionary
                    del active_matches_by_ad[ad_id]
                
                canceled = True
                cancel_message = "ðŸŽ€ Sweetie, your match advertisement has been removed! " + random.choice(MOMMY_SUCCESS_VARIANTS)
        
        # If still not found, let the user know
        if not canceled:
            await ctx.send("âŒ Oh dear, you don't have an active match to cancel, sweetie! ðŸ˜¢")
            return
        
        # Send success message
        await ctx.send(cancel_message)
        
    except Exception as e:
        logger.error(f"Error in matchcancel command: {e}", exc_info=True)
        await ctx.send(random.choice(MOMMY_ERROR_VARIANTS))

# =============================
# MATCHRESULTS COMMAND (aliases: mr, mresults)
# =============================
@bot.command(name='matchresults', aliases=['mr', 'mresults'])
async def match_results(ctx):
    try:
        if ctx.author.id not in pending_results:
            await ctx.send("âŒ Darling, you have no pending match results to submit! (Only the match creator can submit match results)")
            return
        match_state = pending_results[ctx.author.id]
        if ctx.author.id != match_state.creator.id:
            await ctx.send("âŒ Darling, only the match creator can submit match results!")
            return
        dm_channel = await ctx.author.create_dm()
        prompt = (
            "ðŸ’– Hello, my dazzling match creator! Mommy is ready to process your match result.\n\n"
            "Please tell me: Which team won the match? Type '1' for Team 1 or '2' for Team 2.\n"
            "Once you decide, I'll ask for a screenshot URL as proof. Take your timeâ€”Mommy wants everything to be perfect!"
        )
        await dm_channel.send(prompt)
        def check_team(m):
            return m.author.id == ctx.author.id and m.channel == dm_channel and m.content in ['1', '2']
        try:
            team_response = await wait_for_safe(bot.wait_for('message', check=check_team, timeout=None), 60)
        except asyncio.TimeoutError:
            await dm_channel.send("âŒ Darling, you took too long to respond. Please start the match result submission again.")
            return
        winning_team = int(team_response.content)
        await dm_channel.send(
            "Now, my love, please send me the proof of the match resultâ€”a clear screenshot URL, please!\n"
            "Make sure it's crystal clear, darling!"
        )
        def check_proof(m):
            return m.author.id == ctx.author.id and m.channel == dm_channel and m.content.startswith("http")
        try:
            proof_msg = await wait_for_safe(bot.wait_for('message', check=check_proof, timeout=None), 120)
        except asyncio.TimeoutError:
            await dm_channel.send("âŒ Darling, you took too long to provide proof. Please try again when you're ready.")
            return
        proof = proof_msg.content
        details = (
            f"**Match Type:** {match_state.match_type}v{match_state.match_type}\n"
            f"**Wager:** Â¥{match_state.amount} million\n"
            f"**Region:** {match_state.region}\n"
            f"**Creator's Roblox Username:** {match_state.roblox_username}\n"
        )
        if match_state.private_server:
            details += f"**Private Server:** {match_state.private_server}\n"
        teams_text = "Team 1: " + ", ".join([member.mention for member in match_state.team1]) + "\n"
        teams_text += "Team 2: " + ", ".join([member.mention for member in match_state.team2])
        embed = discord.Embed(
            title="Match Result Submission",
            description=(
                f"**Submitted by:** {ctx.author.mention}\n"
                f"**Winning Team:** {'Team 1' if winning_team == 1 else 'Team 2'}\n"
                f"**Proof:** {proof}\n\n"
                f"{details}\n"
                f"{teams_text}"
            ),
            color=discord.Color.blue()
        )
        embed.set_footer(text="Staff, please react with âœ… to approve or âŒ to decline this match result.")
        win_channel = discord.utils.get(ctx.guild.text_channels, name="âš–ï½œwin-approval")
        if not win_channel:
            await ctx.send("âŒ Oh dear, I can't find the win-approval channel! Please contact a staff member, darling!")
            return
        submission = await win_channel.send(embed=embed)
        await submission.add_reaction("âœ…")
        await submission.add_reaction("âŒ")
        await dm_channel.send("ðŸŽ‰ Darling, your match result submission has been sent for approval! Mommy is proud of your victory!")
        def reaction_check(reaction, user):
            return (not user.bot) and str(reaction.emoji) in ["âœ…", "âŒ"] and reaction.message.id == submission.id
        try:
            reaction, staff_user = await wait_for_safe(bot.wait_for('reaction_add', check=reaction_check, timeout=None), 259200)
        except asyncio.TimeoutError:
            await dm_channel.send("âŒ Oh dear, no staff reacted in time. Please contact a staff member directly, sweetie!")
            return
        winners_dm_variants = [
            "ðŸŽ‰ Congratulations, darling! Your win has boosted your value to Â¥{new_val} million. Mommy is over the moon!",
            "ðŸ‘ Well done, sweetie! Your victory has increased your worth to Â¥{new_val} million. Shine on, my star!",
            "ðŸ† Bravo, my champion! Your win now makes you worth Â¥{new_val} million. Mommy celebrates your success!",
            "âœ¨ You did it, love! Your winning streak has lifted your value to Â¥{new_val} million. Mommy is thrilled!",
            "ðŸ’ Oh, my victorious Novarian, your triumph has elevated your value to Â¥{new_val} million. Keep dazzling!"
        ]
        losers_dm_variants = [
            "ðŸ˜¢ Oh no, darling, a loss means your value now dips to Â¥{new_val} million. Mommy knows you'll bounce back!",
            "ðŸ’” Tough match, sweetie. Your value is now Â¥{new_val} million. Every champion faces setbacksâ€”rise again!",
            "ðŸ˜ž A loss stings, but it's only temporary. Your value has been adjusted to Â¥{new_val} million. Mommy believes in you!",
            "ðŸ¥€ Oh dear, not the result you hoped for. Your value now sits at Â¥{new_val} million. Remember, darling, every setback is a setup for a comeback!",
            "ðŸŒ§ï¸ Tough break, sweetie. Your value has dropped to Â¥{new_val} million. Mommy is here to support youâ€”keep your head high!"
        ]
        declined_dm_variants = [
            "âŒ Darling, your match result submission was declined by staff. No changes have been made to your value. Please contact a staff member for more details.",
            "ðŸš« Oh dear, the result submission didn't pass, sweetie. Your wagers have been refunded. Mommy advises you to double-check next time!",
            "ðŸ˜” Sorry, love, but staff rejected the result. Your value remains unchanged, and all wagers have been refunded. Reach out if you have questions.",
            "ðŸ™…â€â™€ï¸ Darling, the submission was declined. Your match result wasn't approved, and everything is back to normal. Mommy is here if you need help!",
            "ðŸ›‘ Oops, sweetie, staff didn't approve your result submission. No adjustments were made, and your wager has been returned. Please consult a staff member for assistance."
        ]
        if str(reaction.emoji) == "âœ…":
            for member in match_state.team1:
                old_val = data_manager.get_member_value(str(member.id))
                new_val = old_val + match_state.amount if winning_team == 1 else old_val - match_state.amount
                data_manager.set_member_value(str(member.id), new_val)
                player_values_channel = discord.utils.get(ctx.guild.text_channels, name="ðŸ’¸-player-values")
                if player_values_channel:
                    await player_values_channel.send(f"{member.mention}, your updated value is now Â¥{new_val} million!")
                dm = await member.create_dm()
                dm_message = (random.choice(winners_dm_variants) if winning_team == 1 else random.choice(losers_dm_variants)).format(new_val=new_val)
                await dm.send(dm_message)
            for member in match_state.team2:
                old_val = data_manager.get_member_value(str(member.id))
                new_val = old_val + match_state.amount if winning_team == 2 else old_val - match_state.amount
                data_manager.set_member_value(str(member.id), new_val)
                player_values_channel = discord.utils.get(ctx.guild.text_channels, name="ðŸ’¸-player-values")
                if player_values_channel:
                    await player_values_channel.send(f"{member.mention}, your updated value is now Â¥{new_val} million!")
                dm = await member.create_dm()
                dm_message = (random.choice(winners_dm_variants) if winning_team == 2 else random.choice(losers_dm_variants)).format(new_val=new_val)
                await dm.send(dm_message)
            await win_channel.send("ðŸŽ‰ Staff approved the match result! Wager values have been updated accordingly!")
            await dm_channel.send("ðŸŽ‰ Darling, your match result was approved! Mommy is proud of your victory!")
        else:
            await win_channel.send("âŒ Staff rejected the match result submission. All wagers have been refunded.")
            for participant in match_state.team1 + match_state.team2:
                dm = await participant.create_dm()
                dm_message = random.choice(declined_dm_variants)
                await dm.send(dm_message)
            await dm_channel.send("âŒ Darling, your match result submission was declined. All wagers have been refunded. Please contact staff for further details.")
        del pending_results[ctx.author.id]
    except Exception as e:
        logger.error(f"Error in matchresults command: {e}", exc_info=True)
        await ctx.send(random.choice(MOMMY_ERROR_VARIANTS))

@bot.command(name='matchresult')
async def match_result(ctx, winning_team: Optional[str] = None):
    try:
        await ctx.send("â³ Darling, match result submission is now handled via `!matchresults` (or its aliases). Please use that command to report your match outcome!")
    except Exception as e:
        logger.error(f"Error in matchresult command: {e}", exc_info=True)
        await ctx.send(random.choice(MOMMY_ERROR_VARIANTS))

@bot.command(name='checkvalue')
async def check_value_cmd(ctx, member: Optional[discord.Member] = None):
    try:
        # Get server configuration for multi-server support
        from server_config import get_channel_id, get_server_setting, get_server_name, uses_sassy_language

        target = member or ctx.author
        server_id = str(ctx.guild.id)
        
        # Get the member's ID as string (works across all servers)
        target_id = str(target.id)
        
        # Get value from shared data storage (values are shared across all servers)
        value = data_manager.get_member_value(target_id)
        
        # Check if we should use sassy language for this server
        use_sassy = uses_sassy_language(server_id)
        
        # For players with 0 value, direct them to the evaluation channel
        if value == 0:
            evaluation_channel_id = 1360249667555950764  # The specific channel ID for evaluations
            
            # Create a server-appropriate message directing them to the evaluation channel
            if use_sassy:
                response = (
                    f"ðŸ’– Oh sweetie! {target.mention}, you don't have a player value yet! ðŸ’«\n\n"
                    f"Mommy needs you to get evaluated by our evaluators to determine your value.\n"
                    f"Please go to <#{evaluation_channel_id}> and read the instructions to get started, darling! ðŸŒŸ"
                )
            else:
                # Professional responses for BLR server with multiple variants
                professional_zero_value_variants = [
                    f"**ðŸ“‹ Player Notice:** {target.name} has not been evaluated yet.\n\nVisit <#{evaluation_channel_id}> to participate in player assessment and receive your valuation.",
                    f"**âš½ Scouting Required:** {target.name} needs an official evaluation.\n\nPlease proceed to <#{evaluation_channel_id}> to schedule your skill assessment.",
                    f"**ðŸ“Š Evaluation Needed:** No value on record for {target.name}.\n\nHead to <#{evaluation_channel_id}> to complete the official player assessment process.",
                    f"**ðŸ” Talent Scouts Notice:** {target.name} requires proper evaluation.\n\nVisit <#{evaluation_channel_id}> to showcase your skills and receive an official valuation.",
                    f"**âš ï¸ Attention {target.name}:** Your player value is pending assessment.\n\nPlease report to <#{evaluation_channel_id}> for official evaluation by our team.",
                    f"**ðŸ“ Registration Incomplete:** {target.name} needs skill assessment.\n\nComplete your player profile by visiting <#{evaluation_channel_id}> for evaluation.",
                    f"**ðŸ’¼ Transfer Status:** {target.name} has no current market value.\n\nGet evaluated at <#{evaluation_channel_id}> to establish your position in the transfer market.",
                    f"**ðŸ† Competition Alert:** {target.name} requires official ranking.\n\nVisit <#{evaluation_channel_id}> to have your skills assessed by our evaluation team.",
                    f"**ðŸŒŸ Player Profile:** {target.name} is not yet evaluated.\n\nPlease visit <#{evaluation_channel_id}> to establish your official player rating and value.",
                    f"**ðŸ“ˆ Development Tracking:** No baseline value established for {target.name}.\n\nProceed to <#{evaluation_channel_id}> to receive your initial player assessment."
                ]
                response = random.choice(professional_zero_value_variants)
        elif value < 100:
            if use_sassy:
                # Use sassy low value responses for members with value under 100
                response = random.choice(MOMMY_LOW_VALUE_VARIANTS).format(value=value)
            else:
                # Professional responses for BLR server with playful teasing for low values
                professional_low_value_variants = [
                    f"ðŸ“Š {target.name}'s value is a modest Â¥{value} million. Room for improvement! ðŸ“ˆ",
                    f"ðŸ’¼ Â¥{value} million valuation for {target.name}. Keep developing those skills! ðŸ†",
                    f"ðŸ” Analysis shows {target.name} at Â¥{value} million - more training could boost that figure! âš½",
                    f"ðŸ“‰ Current market value: Â¥{value} million. {target.name} needs more highlights on the pitch! ðŸŽ¯",
                    f"âš ï¸ {target.name}'s current valuation: Â¥{value} million. Below league average! ðŸ“Š",
                    f"ðŸ”” {target.name}: Â¥{value} million. The scouts are expecting more from you! ðŸ”Ž",
                    f"ðŸ“‹ Performance review: {target.name} valued at Â¥{value} million. Additional training recommended! ðŸ’ª",
                    f"âš½ {target.name}'s market value: Â¥{value} million. The transfer window might be tough! ðŸ“±",
                    f"ðŸŸï¸ Fan perception of {target.name}: Â¥{value} million. Let's aim higher! ðŸŽ–ï¸",
                    f"ðŸ“Š Statistical analysis puts {target.name} at Â¥{value} million. Consider specialized training! ðŸ¥‡"
                ]
                response = random.choice(professional_low_value_variants)
        else:
            if use_sassy:
                # Use normal responses for members with value >= 100
                response = random.choice(MOMMY_CHECKVALUE_VARIANTS).format(value=value)
            else:
                # Professional responses for BLR server with appropriate tone for higher values
                professional_high_value_variants = [
                    f"ðŸŒŸ {target.name}'s market value: Â¥{value} million. Impressive performance stats! ðŸ“ˆ",
                    f"ðŸ’° {target.name} is currently valued at Â¥{value} million. Strong positioning on the field! âš½",
                    f"ðŸ† Talent analysis puts {target.name} at Â¥{value} million. Quality play recognized! ðŸ‘",
                    f"ðŸ“Š Financial valuation: {target.name} is worth Â¥{value} million. A valuable team asset! ðŸ’Ž",
                    f"ðŸ” Scouts value {target.name} at Â¥{value} million. Stand-out performances noted! ðŸŽ¯",
                    f"ðŸ’¼ Transfer market value for {target.name}: Â¥{value} million. Remarkable skill set! ðŸ”",
                    f"ðŸ“± {target.name}'s current value: Â¥{value} million. Competitive in today's market! ðŸ¥‡",
                    f"âš½ Performance metrics value {target.name} at Â¥{value} million. Excellent form! ðŸ”¥",
                    f"ðŸŸï¸ Fan favorite {target.name} valued at Â¥{value} million. Respected by the crowd! ðŸ‘‘",
                    f"ðŸŒ Global market value: {target.name} at Â¥{value} million. International quality! ðŸŒ"
                ]
                response = random.choice(professional_high_value_variants)
        
        # Send the response in the current channel
        await ctx.send(response)
        
        # Log which server the command was used in
        logger.info(f"Checked value for {target_id} (value: {value}) in server {server_id}")
        
        # Optionally post in the server's values channel if configured to do so
        should_announce = get_server_setting("announce_value_checks", server_id)
        if should_announce:
            values_channel_id = get_channel_id("values", server_id)
            if values_channel_id and values_channel_id.isdigit():
                # If the channel ID is valid, post there too (if different from current channel)
                values_channel = ctx.guild.get_channel(int(values_channel_id))
                if values_channel and values_channel.id != ctx.channel.id:
                    # Format a server-appropriate announcement based on value
                    server_name = get_server_name(server_id) or "Novera"
                    
                    if value == 0:
                        # Special announcement for zero value - direct them to evaluations
                        evaluation_channel_id = 1360249667555950764  # Evaluation channel
                        announcement = f"âš ï¸ {target.mention} needs to be evaluated! Please visit <#{evaluation_channel_id}> to get your player value."
                    else:
                        # Normal announcement for positive value
                        announcement = f"ðŸ’° {target.mention}'s value in {server_name} is Â¥{value} million! âœ¨"
                        
                    await values_channel.send(announcement)
                    logger.info(f"Announced value check in values channel for {target_id} in server {server_id}")
                    
    except Exception as e:
        logger.error(f"Error in checkvalue command: {e}", exc_info=True)
        await ctx.send(random.choice(MOMMY_ERROR_VARIANTS))

@bot.command(name='activity')
async def activity_cmd(ctx, member: Optional[discord.Member] = None):
    try:
        # Get server configuration
        from server_config import get_server_setting, get_server_name
        
        # Get server ID
        server_id = str(ctx.guild.id)
        
        # Get member info
        target = member or ctx.author
        target_id = str(target.id)
        
        # Get activity data (shared across servers)
        activity = activity_tracker.data_manager.get_activity(target_id)
        
        # Format the response
        server_name = get_server_name(server_id) or "Novera"
        response = random.choice(MOMMY_ACTIVITY_VARIANTS).format(activity=activity)
        
        # Send response
        await ctx.send(response)
        
        # Log with server ID
        logger.info(f"Checked activity for {target_id} in server {server_id}")
    except Exception as e:
        logger.error(f"Error in activity command: {e}", exc_info=True)
        await ctx.send(random.choice(MOMMY_ERROR_VARIANTS))

@bot.command(name='spank')
async def spank_cmd(ctx, member: Optional[discord.Member] = None):
    try:
        # Get server-specific configuration
        from server_config import is_command_disabled, get_message_style
        
        # Get the server ID
        server_id = str(ctx.guild.id)
        
        # Check if this command is disabled in the current server
        if is_command_disabled("spank", server_id):
            error_msg = get_message_style("error", server_id)
            await ctx.send(f"This command is not available on this server. {error_msg}")
            return
            
        if not has_spank_permission(ctx.author):
            await ctx.send(random.choice(MOMMY_PERMISSION_DENIED))
            return
        if not member:
            await ctx.send("Oh dear, please mention someone to spank, darling! ðŸ™")
            return
        response = get_random_spank_response(member)
        count = data_manager.get_member_data(str(member.id), 'spank_count', 0)
        count += 1
        data_manager.set_member_data(str(member.id), 'spank_count', count)
        await ctx.send(response)
        if count >= 3:
            await ctx.send(get_spank_warning_response(member))
            data_manager.set_member_data(str(member.id), 'spank_count', 0)
    except Exception as e:
        logger.error(f"Error in spank command: {e}", exc_info=True)
        
        # Use server-specific error message
        from server_config import get_message_style, uses_sassy_language
        server_id = str(ctx.guild.id)
        if uses_sassy_language(server_id):
            await ctx.send(random.choice(MOMMY_ERROR_VARIANTS))
        else:
            error_msg = get_message_style("error", server_id)
            await ctx.send(f"Error processing your request. {error_msg}")

@bot.command(name='headpat')
async def headpat_cmd(ctx, member: Optional[discord.Member] = None):
    try:
        # Get server-specific configuration
        from server_config import get_server_setting, get_server_name, is_command_disabled, get_message_style, uses_sassy_language
        
        # Get the server ID
        server_id = str(ctx.guild.id)
        
        # Check if this command is disabled in the current server
        if is_command_disabled("headpat", server_id):
            error_msg = get_message_style("error", server_id)
            await ctx.send(f"This command is not available on this server. {error_msg}")
            return
            
        # Check permissions using server-specific roles
        if not has_value_management_role(ctx.author):
            await ctx.send(random.choice(MOMMY_PERMISSION_DENIED))
            return
            
        # Validate member to headpat
        if not member:
            # Use server-specific language style
            if uses_sassy_language(server_id):
                await ctx.send("Oh dear, please mention someone to headpat, sweetheart! ðŸ™")
            else:
                await ctx.send("Please specify a user to give recognition to.")
            return
            
        if member.id == ctx.author.id:
            # Use server-specific language style
            if uses_sassy_language(server_id):
                await ctx.send("Oopsie, you can't headpat yourself, darling! Try giving someone else a pat. ðŸ¤—")
            else:
                await ctx.send("You cannot use this command on yourself.")
            return
            
        # Check if using sassy language for this server
        use_sassy = uses_sassy_language(server_id)
        
        # Generate and send response based on server's language style
        if use_sassy:
            response = get_random_headpat_response(member)
            await ctx.send(response)
        else:
            # Professional responses for BLR server with multiple variants
            professional_headpat_variants = [
                f"ðŸ† Recognition awarded to {member.name} for outstanding performance! ðŸ‘",
                f"ðŸŒŸ {member.name} has been recognized for quality contributions! ðŸ“ˆ",
                f"âš½ {member.name} receives official acknowledgment for excellent play! ðŸ’¯",
                f"ðŸ“Š Performance recognition granted to {member.name}! ðŸ”",
                f"ðŸ” Scouts have recognized {member.name}'s recent efforts! ðŸ“",
                f"ðŸ’¼ Official commendation registered for {member.name}! â­",
                f"ðŸŸï¸ {member.name} has been formally recognized by management! ðŸ‘‘",
                f"ðŸ“± {member.name} receives staff recognition for recent contributions! ðŸŽ¯",
                f"ðŸŒ Team coordinators acknowledge {member.name}'s exceptional work! ðŸ¥‡",
                f"âš¡ {member.name} has earned formal recognition from the organization! ðŸ’ª"
            ]
            await ctx.send(random.choice(professional_headpat_variants))
        
        # Track headpat count with server-specific key to keep them separate
        count_key = f'headpat_count_{server_id}'
        count = data_manager.get_member_data(str(member.id), count_key, 0)
        count += 1
        data_manager.set_member_data(str(member.id), count_key, count)
        
        # Check if headpat count reached threshold for goodboy role
        if count >= 3:
            # Get the appropriate goodboy role based on server ID
            goodboy_role_id = None
            goodboy = None
            
            # Check which server we're in and get the appropriate role
            if server_id == "1350165280940228629":  # Original server
                goodboy = discord.utils.get(ctx.guild.roles, name="ðŸ¥°GOODBOYðŸ¥°")
            elif server_id == "1301830184307130401":  # Second server
                goodboy = discord.utils.get(ctx.guild.roles, id=1354617086785093875)
            
            if not goodboy:
                if use_sassy:
                    await ctx.send("Oh dear, the goodboy role wasn't found! Please create it, my love! ðŸ˜¢")
                else:
                    await ctx.send("The recognition role could not be found. Please contact an administrator.")
                return
                
            # Remove the role from any current members who have it in this server
            for m in ctx.guild.members:
                if goodboy in m.roles:
                    await m.remove_roles(goodboy)
                    if use_sassy:
                        await ctx.send(f"{m.mention} is no longer Mommy's favorite good boy in this server! ðŸ˜”")
                    else:
                        await ctx.send(f"{m.mention} no longer has the recognition role.")
            
            # Add the role to the new goodboy
            await member.add_roles(goodboy)
            
            # Get server name for customized message
            server_name = get_server_name(server_id) or "Novera"
            
            if use_sassy:
                success_msg = random.choice(MOMMY_SUCCESS_VARIANTS)
                await ctx.send(f"ðŸŽ‰ Congratulations {member.mention}! You're now Mommy's favorite good boy in {server_name}! {success_msg}")
            else:
                # Professional response for BLR server
                success_msg = get_message_style("success", server_id)
                await ctx.send(f"Congratulations {member.mention}! You've been awarded the recognition role in {server_name}. {success_msg}")
            
            # Reset the headpat count for this server
            data_manager.set_member_data(str(member.id), count_key, 0)
    except Exception as e:
        logger.error(f"Error in headpat command: {e}", exc_info=True)
        
        # Use server-specific error message style
        from server_config import get_message_style, uses_sassy_language
        server_id = str(ctx.guild.id)
        if uses_sassy_language(server_id):
            await ctx.send(random.choice(MOMMY_ERROR_VARIANTS))
        else:
            error_msg = get_message_style("error", server_id)
            await ctx.send(f"Error processing your request. {error_msg}")

@bot.command(name='eval')
async def tryoutsresults_cmd(ctx, member: discord.Member):
    try:
        # Import server configuration
        from server_config import get_channel_id, get_server_setting, get_role_id
        
        # Get server ID and settings
        server_id = str(ctx.guild.id)
        
        # Initial validation
        if ctx.author.id == member.id:
            await ctx.send("Oh dear, you cannot evaluate yourself, sweetheart! Please let someone else help. ðŸ˜“")
            return
        
        # Get the pro role for validation
        pro_role_id = get_role_id("pro", server_id)
        if pro_role_id:
            pro_role = discord.utils.get(ctx.guild.roles, id=int(pro_role_id))
            if pro_role in member.roles:
                await ctx.send("Oopsie, this player is already a professional! Mommy is so proud of them! ðŸ˜")
                return
                
        # Check if the evaluator already has an active tryout
        if ctx.author.id in active_tryouts:
            await ctx.send("Darling, you already have an active tryout evaluation! Please cancel it with !tryoutcancel before starting another. ðŸ™‡")
            return
        
        # Get the tryout results channel for message customization
        tryout_channel_id = get_channel_id("tryout_results", server_id)
        if tryout_channel_id and tryout_channel_id.isdigit():
            channel_mention = f"<#{tryout_channel_id}>"
        else:
            channel_mention = "the tryout results channel"
            
        # Send a "please wait" message to the player being evaluated in sassy mommy style
        try:
            player_dm = await member.create_dm()
            await player_dm.send(
                "ðŸ’– **Oh darling!** ðŸ’–\n\n"
                f"Mommy's noticed that {ctx.author.name} is evaluating your skills right now! "
                "Just sit tight, sweetheart - this won't take long! ðŸ’…âœ¨\n\n"
                f"Your results will appear in {channel_mention} soon! "
                "Mommy's so excited to see how you shine! ðŸŒŸ"
            )
            logger.info(f"Sent wait notification to player {member.id} in server {server_id}")
        except discord.Forbidden:
            logger.warning(f"Could not send DM to player {member.id} - DMs might be disabled")
            # Continue anyway since this is not critical
            
        # Store server ID with the active tryout for multi-server support
        active_tryouts[ctx.author.id] = {
            "member": member, 
            "server_id": server_id,
            "guild": ctx.guild,  # Store the guild object directly for later use
            "from_command": True  # Flag that indicates this tryout was started from the tryoutsresults command
        }
        await ctx.send("ðŸ“© Sweetheart, check your DMs to complete the tryout evaluation!")
        
        # Send the evaluation instructions to the evaluator
        dm = await ctx.author.create_dm()
        await dm.send(
            "**ðŸ“Š Player Position Selection**\n\n"
            "Welcome to the Novera Tryouts Evaluation System! ðŸ“‹\n\n"
            "Please select the player's position:\n"
            "> Type `1` for GK (Goalkeeper)\n"
            "> Type `2` for CM (Central Midfielder)\n"
            "> Type `3` for LW/RW (Winger)\n"
            "> Type `4` for CF (Center Forward)"
        )
    except Exception as e:
        logger.error(f"Error in tryoutsresults command: {e}", exc_info=True)
        await ctx.send(random.choice(MOMMY_ERROR_VARIANTS))

@bot.command(name='tryoutcancel')
async def tryoutcancel_cmd(ctx):
    try:
        # Get server ID
        server_id = str(ctx.guild.id)
        
        if ctx.author.id not in active_tryouts:
            await ctx.send("Oh dear, you don't have an active tryout evaluation to cancel, my love! ðŸ˜”")
            return
            
        # Get the tryout info
        tryout_info = active_tryouts[ctx.author.id]
        
        # Log which server the command was executed in
        logger.info(f"User {ctx.author.id} canceled a tryout for {tryout_info.get('member', 'unknown')} in server {server_id}")
        
        # Remove the tryout
        del active_tryouts[ctx.author.id]
        
        await ctx.send("âœ… Darling, your tryout evaluation has been cancelled! Good job, sweetie! ðŸŽ‰")
    except Exception as e:
        logger.error(f"Error in tryoutcancel command: {e}", exc_info=True)
        await ctx.send(random.choice(MOMMY_ERROR_VARIANTS))

# Button for Evaluation Request
class EvaluationRequestButton(discord.ui.View):
    def __init__(self, player_id: int, timeout=300):
        super().__init__(timeout=timeout)
        self.player_id = player_id
        
    @discord.ui.button(label="Evaluate Me", style=discord.ButtonStyle.primary, emoji="ðŸ“‹")
    async def evaluate_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        try:
            # Import server configuration
            from server_config import get_channel_id, get_server_setting, get_role_id, has_management_permission
            
            # Get server ID and player's member object
            server_id = str(interaction.guild.id)
            player = interaction.guild.get_member(self.player_id)
            
            # Make sure only the original player can click the button
            if interaction.user.id != self.player_id:
                # Check if we should use sassy language
                from server_config import uses_sassy_language
                use_sassy = uses_sassy_language(server_id)
                
                if use_sassy:
                    await interaction.response.send_message("This button wasn't meant for you, sweetheart! Let the player request their own evaluation. ðŸ’–", ephemeral=True)
                else:
                    await interaction.response.send_message("This button is only for the player who requested the evaluation.", ephemeral=True)
                return
                
            # For the BLR server with ID 1345538548027232307, we need special handling
            if server_id == "1345538548027232307":
                # Check if player already has a value (only players with value=0 can be evaluated)
                current_value = data_manager.get_member_value(str(self.player_id))
                
                # Check if we should use sassy language
                from server_config import uses_sassy_language
                use_sassy = uses_sassy_language(server_id)
                
                if current_value > 0:
                    if use_sassy:
                        await interaction.response.send_message(f"Oh darling, you already have a value of Â¥{current_value} million! You don't need another evaluation! ðŸ’…", ephemeral=True)
                    else:
                        await interaction.response.send_message(f"You already have a value of Â¥{current_value} million. No additional evaluation is needed.", ephemeral=True)
                    return
                    
                # Get the evaluation request channel ID
                eval_request_channel_id = get_channel_id("evaluation_requests", server_id)
                if not eval_request_channel_id or not eval_request_channel_id.isdigit():
                    await interaction.response.send_message("Oh dear, the evaluation request channel doesn't seem to be configured properly! Please contact staff. ðŸ˜“", ephemeral=True)
                    return
                
                # Get the eval request channel object
                eval_request_channel = interaction.guild.get_channel(int(eval_request_channel_id))
                if not eval_request_channel:
                    await interaction.response.send_message("Oh sweetie, Mommy couldn't find the evaluation request channel! Please let staff know. ðŸ™‡", ephemeral=True)
                    return
                    
                # Create an embedded evaluation request in the request channel
                embed = discord.Embed(
                    title="âœ¨ Player Evaluation Request âœ¨",
                    description=f"{player.mention} is eager to be evaluated! This player currently has no value assigned.",
                    color=discord.Color.blue()
                )
                embed.add_field(name="Player", value=f"{player.display_name} ({player.mention})", inline=True)
                embed.add_field(name="Requested", value=f"<t:{int(time.time())}:R>", inline=True)
                embed.set_footer(text="To evaluate this player, use the !eval command with their @mention")
                
                # Include any evaluator role mentions
                from server_config import get_role_ids
                evaluator_role_ids = get_role_ids("management", server_id)
                role_mentions = []
                for role_id in evaluator_role_ids:
                    role = interaction.guild.get_role(int(role_id))
                    if role:
                        role_mentions.append(role.mention)
                
                # Post the request with role mentions if any
                if role_mentions:
                    await eval_request_channel.send(" ".join(role_mentions), embed=embed)
                else:
                    await eval_request_channel.send(embed=embed)
                
                # Inform the player their request has been submitted
                await interaction.response.send_message("ðŸ’– Your evaluation request has been submitted, darling! An evaluator will review your skills soon! ðŸ’…âœ¨", ephemeral=True)
                logger.info(f"Evaluation request submitted for player {self.player_id} in server {server_id}")
            else:
                # For other servers, just inform the player this command is only for the BLR server
                await interaction.response.send_message("Oh darling, this evaluation system is only available on the BLR: NoVera E-Sports League server! ðŸ’", ephemeral=True)
                
        except Exception as e:
            logger.error(f"Error processing evaluation button: {e}", exc_info=True)
            await interaction.response.send_message(random.choice(MOMMY_ERROR_VARIANTS), ephemeral=True)

@bot.command(name='getevaluated')
async def getevaluated_cmd(ctx):
    try:
        # Import server configuration
        from server_config import get_channel_id, get_server_setting, get_role_id
        
        # Get server ID
        server_id = str(ctx.guild.id)
        
        # Check player's current value (this applies to all servers)
        current_value = data_manager.get_member_value(str(ctx.author.id))
        
        # Only players with value=0 can use this command
        if current_value > 0:
            # Check if we should use sassy language for this server
            from server_config import uses_sassy_language
            use_sassy = uses_sassy_language(server_id)
            
            if use_sassy:
                await ctx.send(f"Oh sweetie! ðŸ’– You already have a value of Â¥{current_value} million. Mommy has already evaluated you! No need for another evaluation, darling! ðŸ’‹")
            else:
                await ctx.send(f"You already have a value of Â¥{current_value} million. No additional evaluation is needed.")
            return
            
        # For the BLR server with ID 1345538548027232307, we need special handling
        if server_id == "1345538548027232307":
                
            # Create a view with the evaluation request button
            view = EvaluationRequestButton(ctx.author.id)
            
            # Check if we should use sassy language for this server
            from server_config import uses_sassy_language
            use_sassy = uses_sassy_language(server_id)
            
            if use_sassy:
                # Original sassy message
                await ctx.send(
                    "ðŸ’– **Want to be evaluated, my precious?** ðŸ’–\n\n"
                    "Mommy's evaluation system will assess your skills and determine your value!\n"
                    "Click the button below to request an evaluation from our team. An evaluator will be with you soon!\n\n"
                    "Remember, darling - only players who have not been evaluated yet can use this feature.",
                    view=view
                )
            else:
                # Professional message for BLR server
                await ctx.send(
                    "**Player Evaluation Request**\n\n"
                    "The evaluation system will assess your skills and determine your market value.\n"
                    "Click the button below to request an evaluation from our team. An evaluator will review your request soon.\n\n"
                    "Note: This feature is only available for players who have not yet been evaluated.",
                    view=view
                )
            
            logger.info(f"Evaluation button created for player {ctx.author.id} in server {server_id}")
        else:
            # For other servers, inform the player this command is only for the BLR server
            await ctx.send("Oh darling, this evaluation system is only available on the BLR: NoVera E-Sports League server! ðŸ’")
            
    except Exception as e:
        logger.error(f"Error in getevaluated command: {e}", exc_info=True)
        await ctx.send(random.choice(MOMMY_ERROR_VARIANTS))

@bot.command(name='giveaway')
async def giveaway_cmd(ctx, duration: str):
    try:
        # Initialize total_seconds before conditionals
        total_seconds = 0
        
        unit = duration[-1].lower()
        if unit not in ['s', 'm', 'h', 'd']:
            await ctx.send("âŒ Oh dear, please use a valid time unit: s (seconds), m (minutes), h (hours) or d (days), sweetie! â°")
            return
        try:
            time_val = int(duration[:-1])
        except ValueError:
            await ctx.send("âŒ Oopsie, darling! I couldn't understand the duration number. Please try again! ðŸ”¢")
            return
        if unit == 's':
            total_seconds = time_val
        elif unit == 'm':
            total_seconds = time_val * 60
        elif unit == 'h':
            total_seconds = time_val * 3600
        elif unit == 'd':
            total_seconds = time_val * 86400
        giveaway_channel = discord.utils.get(ctx.guild.text_channels, name="ðŸŽ-giveaways")
        if not giveaway_channel:
            await ctx.send("âŒ Oh dear, I can't find the 'ðŸŽ-giveaways' channel! Please create one, sweetie! ðŸ“£")
            return
        embed = discord.Embed(
            title="ðŸŽ‰ Giveaway Time, Sweethearts!",
            description=(
                f"Hello, my precious Novarians! Mommy is hosting a giveaway!\n"
                f"React with ðŸŽ‰ to join the fun and stand a chance to win!\n"
                f"This delightful giveaway ends in **{duration}**.\n\n"
                "Don't miss outâ€”show your excitement and join in, darling! ðŸ’–"
            ),
            color=discord.Color.purple()
        )
        embed.set_footer(text="Good luck, my dears!")
        giveaway_message = await giveaway_channel.send(embed=embed)
        await giveaway_message.add_reaction("ðŸŽ‰")
        await ctx.send(f"âœ… Darling, the giveaway has started in {giveaway_channel.mention} and will last for {duration}! {random.choice(MOMMY_SUCCESS_VARIANTS)}")
        await asyncio.sleep(total_seconds)
        updated_message = await giveaway_channel.fetch_message(giveaway_message.id)
        reaction = discord.utils.get(updated_message.reactions, emoji="ðŸŽ‰")
        if reaction is None:
            await giveaway_channel.send("Oh dear, no one reacted to this giveaway. Mommy is a little disappointed, sweetie! ðŸ˜”")
            return
        users = await reaction.users().flatten()
        entrants = [user for user in users if not user.bot]
        if not entrants:
            await giveaway_channel.send("Oh dear, it seems no one joined the giveaway. Maybe next time, sweethearts! ðŸ™")
            return
        winner = random.choice(entrants)
        await giveaway_channel.send(f"ðŸŽ‰ Congratulations, {winner.mention}! You are Mommy's lucky winner! Enjoy your prize, darling! {random.choice(MOMMY_SUCCESS_VARIANTS)}")
    except Exception as e:
        logger.error(f"Error in giveaway command: {e}", exc_info=True)
        await ctx.send(random.choice(MOMMY_ERROR_VARIANTS))

@bot.command(name='rankings')
async def rankings_cmd(ctx):
    try:
        # Get server-specific configuration
        from server_config import get_server_setting, get_server_name, get_role_id
        
        # Get the server ID
        server_id = str(ctx.guild.id)
        server_name = get_server_name(server_id) or "Novera"
        
        # Get all values from shared storage
        all_values = data_manager.get_all_member_values()
        if not all_values:
            await ctx.send("Oh dear, no values found yet! Mommy needs more Novarians to shine, sweetie! âœ¨")
            return
            
        # Sort by value
        sorted_by_value = sorted(all_values.items(), key=lambda x: x[1], reverse=True)
        
        # Get top 3 overall
        top_three = []
        
        # Filter for members in this server only
        members_in_server = 0
        for member_id, value in sorted_by_value:
            # Check if this member is in this server
            member = ctx.guild.get_member(int(member_id))
            if member:
                top_three.append((member_id, value))
                members_in_server += 1
                # Only need top 3
                if len(top_three) >= 3:
                    break
        
        if not top_three:
            await ctx.send(f"Oh dear, Mommy couldn't find any valued members in this server! Try evaluating some players, sweetie! âœ¨")
            return
            
        # Get growth data
        growth_data = data_manager.get_value_growth_3days()
        trending_member_id = None
        
        # Filter growth data for members in this server
        if growth_data:
            filtered_growth = {mid: val for mid, val in growth_data.items() if ctx.guild.get_member(int(mid))}
            if filtered_growth:
                trending_member_id, _ = max(filtered_growth.items(), key=lambda x: x[1])
            
        # If no trending member found, use top player
        if not trending_member_id and top_three:
            trending_member_id = top_three[0][0]
            
        # Handle roles differently for each server
        if server_id == "1350165280940228629":  # Original server
            # Find the rank roles by name
            rank1_role = discord.utils.get(ctx.guild.roles, name="ðŸ¥‡ Rank1")
            rank2_role = discord.utils.get(ctx.guild.roles, name="ðŸ¥ˆ Rank 2")
            rank3_role = discord.utils.get(ctx.guild.roles, name="ðŸ¥‰ Rank 3")
            trending_role = discord.utils.get(ctx.guild.roles, name="ðŸŒŸTRENDING")
            
            # Clear existing rank roles
            roles_to_clear = [rank1_role, rank2_role, rank3_role, trending_role]
            for role in roles_to_clear:
                if role:
                    for member in role.members:
                        try:
                            await member.remove_roles(role)
                        except Exception as e:
                            logger.error(f"Error removing role {role.name} from {member.id}: {e}", exc_info=True)
            
            # Assign roles to top three
            if top_three:
                member_obj = ctx.guild.get_member(int(top_three[0][0]))
                if member_obj and rank1_role:
                    await member_obj.add_roles(rank1_role)
            if len(top_three) >= 2:
                member_obj = ctx.guild.get_member(int(top_three[1][0]))
                if member_obj and rank2_role:
                    await member_obj.add_roles(rank2_role)
            if len(top_three) >= 3:
                member_obj = ctx.guild.get_member(int(top_three[2][0]))
                if member_obj and rank3_role:
                    await member_obj.add_roles(rank3_role)
                    
            # Assign trending role if applicable
            if trending_member_id and trending_role:
                trending_member = ctx.guild.get_member(int(trending_member_id))
                if trending_member:
                    await trending_member.add_roles(trending_role)
        
        # For the second server, we'll just show rankings without assigning roles
        
        # Create a nice embed with rankings for this server
        embed = discord.Embed(
            title=f"ðŸ† {server_name} Rankings",
            description=f"Here are the top players in {server_name} according to Mommy's records!",
            color=discord.Color.gold()
        )
        
        rank_emojis = ["ðŸ¥‡", "ðŸ¥ˆ", "ðŸ¥‰"]
        for i, (member_id, value) in enumerate(top_three):
            member_obj = ctx.guild.get_member(int(member_id))
            if member_obj:
                embed.add_field(name=f"{rank_emojis[i]} Rank {i+1}", value=f"{member_obj.mention} â€“ Â¥{value} million", inline=False)
                
        if trending_member_id:
            trending_member = ctx.guild.get_member(int(trending_member_id))
            if trending_member:
                embed.set_footer(text=f"ðŸŒŸ Trending: {trending_member.display_name}")
                
        await ctx.send(embed=embed)
        logger.info(f"Displayed rankings in server {server_id} with {members_in_server} members")
    except Exception as e:
        logger.error(f"Error in rankings command: {e}", exc_info=True)
        await ctx.send(random.choice(MOMMY_ERROR_VARIANTS))

@bot.command(name="mommy")
async def mommy_help(ctx):
    # Get server ID to show server-specific commands
    server_id = str(ctx.guild.id)
    
    common_commands = (
        "â€¢ **!checkvalue [@member]** â€“ Peek at your current value, darling.\n"
        "â€¢ **!activity [@member]** â€“ See how active you (or your friends) have been, sweetie.\n"
        "â€¢ **!anteup** â€“ Create a match advertisement. Show the world your skills!\n"
        "â€¢ **!matchcancel** â€“ Cancel your current match setup if you change your mind.\n"
        "â€¢ **!matchresults** â€“ Report your match result via DM. (Only the match creator can submit match results.)\n"
        "â€¢ **!giveaway <duration>** â€“ Host a fabulous giveaway (duration: s, m, h, or d).\n"
        "â€¢ **!rankings** â€“ See the top Novarians shining bright!\n"
        "â€¢ **!spill** â€“ Mommy shares juicy gossip about Novarians.\n"
        "â€¢ **!shopping** â€“ Mommy reveals her latest luxury purchases.\n"
        "â€¢ **!tipjar** â€“ Check Mommy's special fund status.\n"
        "â€¢ **!confess** â€“ Mommy admits what she's been up to behind the scenes."
    )
    
    # Add BLR server-specific commands
    if server_id == "1345538548027232307":
        help_text = (
            "ðŸ’– **Hello, my sweet Novarian! I'm Novera Assistantâ€”your ever-loving, sassy Mommy!** ðŸ’–\n\n"
            "**Public Commands:**\n"
            f"{common_commands}\n"
            "â€¢ **!getevaluated** â€“ Request to have your player skills evaluated (for new players only).\n"
            "â€¢ **!eval [@member]** â€“ Evaluate a player to determine their value (evaluator permission required).\n\n"
            "Remember, my precious, Mommy is always here to guide you with love and playful discipline. Now go out there and dazzle the world! ðŸ’–"
        )
    else:
        help_text = (
            "ðŸ’– **Hello, my sweet Novarian! I'm Novera Assistantâ€”your ever-loving, sassy Mommy!** ðŸ’–\n\n"
            "**Public Commands:**\n"
            f"{common_commands}\n\n"
            "Remember, my precious, Mommy is always here to guide you with love and playful discipline. Now go out there and dazzle the world! ðŸ’–"
        )
        
    await ctx.send(help_text)

@bot.event
async def on_command_error(ctx, error):
    # Update last heartbeat on every command error event
    global last_heartbeat
    last_heartbeat = time.time()
    if isinstance(error, commands.CommandNotFound):
        # Only suggest commands if the message starts with "!" and is clearly an attempted command
        command_name = ctx.message.content.split()[0][1:]
        
        # Skip very short command names to avoid false positives
        if len(command_name) < 3:
            return
            
        # Check if this might have been a regular conversation that started with "!"
        # Skip common words and phrases that might start with "!"
        common_words = ["the", "this", "that", "they", "then", "thanks", "thank", "think", 
                        "just", "maybe", "actually", "about", "though", "even", "really", 
                        "still", "also", "some", "what", "when", "where", "how", "can", 
                        "could", "would", "should", "need", "want", "have", "had", "has", 
                        "did", "does", "but", "and", "which", "who", "why"]
        
        if command_name.lower() in common_words:
            return
        
        # More sophisticated command matching - requires either exact prefix match of 3+ characters
        # or 80% similarity for commands over 5 characters
        similar_commands = []
        
        for cmd in bot.commands:
            # Exact prefix match for first 3+ characters
            if len(command_name) >= 3 and cmd.name.startswith(command_name[:3]):
                similar_commands.append(cmd.name)
                continue
                
            # For longer attempted commands, use string similarity
            if len(command_name) >= 5 and len(cmd.name) >= 5:
                # Simple similarity check - count matching characters
                matching_chars = sum(1 for a, b in zip(command_name.lower(), cmd.name.lower()) if a == b)
                similarity = matching_chars / max(len(command_name), len(cmd.name))
                
                if similarity >= 0.8:  # 80% similarity threshold
                    similar_commands.append(cmd.name)
        
        if similar_commands:
            suggestion = f"Perhaps you meant `!{similar_commands[0]}`?"
            await ctx.send(f"Oh sweetie, that command doesn't exist! ðŸ¤” {suggestion} Mommy wants to help you get it right! ðŸ’")
    
    elif isinstance(error, commands.MissingRequiredArgument):
        await ctx.send("Oh dear, you're missing something important in that command, sweetie! ðŸ¤— Let Mommy help you use it correctly! ðŸ’•")

@bot.event
async def on_message(message):
    """
    This event overrides commands.Bot's on_message method.
    If we don't call bot.process_commands(message), no commands will be processed.
    If we call it multiple times, commands may be processed multiple times.
    """
    # Update last heartbeat on every message received
    global last_heartbeat
    last_heartbeat = time.time()
    
    try:
        if message.author.bot:
            return
        # Add extremely detailed logging with process ID, message ID and command prefix detection
        pid = os.getpid()
        is_command = message.content.startswith(COMMAND_PREFIX)
        logger.info(f"[PID:{pid}][MID:{message.id}][CMD:{is_command}] Processing message from {message.author} in {message.channel}: {message.content}")
        
        # Log detailed message context for debugging duplicate responses
        if is_command:
            logger.debug(f"=== COMMAND DEBUG INFO ===")
            logger.debug(f"Message ID: {message.id}")
            logger.debug(f"Process ID: {pid}")
            logger.debug(f"Author: {message.author.id} ({message.author.name})")
            logger.debug(f"Command: {message.content}")
            logger.debug(f"Channel: {message.channel.id} ({message.channel.name if hasattr(message.channel, 'name') else 'DM'})")
            logger.debug(f"Server: {message.guild.id if message.guild else 'DM'}")
            logger.debug(f"==========================")
            
        await activity_tracker.track_message(str(message.author.id))
        # Only check for command suggestions in server channels, not DMs
        if not isinstance(message.channel, discord.DMChannel):
            # Define exact command matches that we'll suggest ! for
            exact_command_names = ['checkvalue', 'matchresults', 'anteup', 'headpat', 'spank', 
                                   'rankings', 'activity', 'matchcancel', 'spill', 'shopping', 
                                   'tipjar', 'confess', 'giveaway']
            
            # Check if this might be a standalone command (not part of a sentence)
            content = message.content.strip().lower()
            first_word = content.split()[0] if content else ""
            
            # More selective command suggestion - only for standalone words that exactly match commands
            # and don't show suggestions for common words that might be in a sentence
            if (
                # Must be a single word or a command with arguments
                (first_word in exact_command_names and (len(content.split()) == 1 or content.split()[1].startswith("@"))) or
                # Or a short message that's just the command name
                (content in exact_command_names)
            ):
                # Check for common prefixes that would indicate this is NOT a command
                common_prefixes = ["i ", "the ", "a ", "this ", "that ", "my ", "our ", "their ", "his ", "her ", "its "]
                preceding_words = message.content.split(first_word)[0].lower()
                
                # Only suggest if this isn't preceded by common words indicating a regular sentence
                if not any(preceding_words.endswith(prefix) for prefix in common_prefixes):
                    # This is very likely an intended command without the ! prefix
                    await message.channel.send("Sweetie, did you forget to add `!` before the command? ðŸŽ€ Mommy needs that to understand what you want! ðŸ’–")
                    return
        if isinstance(message.channel, discord.DMChannel):
            # Handle active server message creation flow
            if message.author.id in active_server_messages:
                try:
                    # Process server message flow steps
                    msg_state = active_server_messages[message.author.id]
                    content = message.content.strip()
                    
                    # Step 1: Server selection
                    if msg_state["step"] == "server_selection":
                        # Get available servers
                        servers = []
                        for i, guild in enumerate(bot.guilds, 1):
                            servers.append((str(i), str(guild.id), guild.name))
                            
                        # Check if input is valid
                        if not content.isdigit() or int(content) < 1 or int(content) > len(servers):
                            await message.channel.send("âŒ Oh darling, please enter a valid server number from the list! ðŸ’–")
                            return
                            
                        # Get selected server
                        selected_num = int(content)
                        selected_server_id = servers[selected_num-1][1]
                        selected_server_name = servers[selected_num-1][2]
                        
                        # Store selection and move to next step
                        msg_state["server_id"] = selected_server_id
                        msg_state["step"] = "channel_selection"
                        
                        # Get server channels for next step
                        guild = bot.get_guild(int(selected_server_id))
                        text_channels = guild.text_channels
                        
                        # Create beautiful embed for channel selection
                        embed = discord.Embed(
                            title="ðŸ’¬ Channel Selection ðŸ’¬",
                            description=f"Now, which channel in **{selected_server_name}** do you want to send your message to?",
                            color=discord.Color.purple()
                        )
                        
                        # Add channel listing with pagination (10 channels per page)
                        channels_per_page = 10
                        channel_count = len(text_channels)
                        
                        for i, channel in enumerate(text_channels[:channels_per_page]):
                            embed.add_field(
                                name=f"#{i+1} {channel.name}",
                                value=f"ID: {channel.id}",
                                inline=False
                            )
                            
                        if channel_count > channels_per_page:
                            embed.set_footer(text=f"Showing 1-{channels_per_page} of {channel_count} channels. Type 'more' to see more channels.")
                        else:
                            embed.set_footer(text="Please enter the channel number or ID from the list above")
                            
                        await message.channel.send(embed=embed)
                        
                    # Step 2: Channel selection
                    elif msg_state["step"] == "channel_selection":
                        # Get the guild
                        guild = bot.get_guild(int(msg_state["server_id"]))
                        text_channels = guild.text_channels
                        
                        # Check for 'more' command
                        if content.lower() == 'more':
                            # Load more channels, up to 10 more
                            more_embed = discord.Embed(
                                title="ðŸ’¬ Channel Selection (Continued) ðŸ’¬",
                                description=f"Additional channels in **{guild.name}**:",
                                color=discord.Color.purple()
                            )
                            
                            # Add more channels
                            already_shown = 10
                            additional = min(10, len(text_channels) - already_shown)
                            
                            for i in range(already_shown, already_shown + additional):
                                channel = text_channels[i]
                                more_embed.add_field(
                                    name=f"#{i+1} {channel.name}",
                                    value=f"ID: {channel.id}",
                                    inline=False
                                )
                                
                            more_embed.set_footer(text="Please enter the channel number or ID from either list")
                            await message.channel.send(embed=more_embed)
                            return
                        
                        # Try to get channel by number
                        selected_channel = None
                        if content.isdigit():
                            channel_num = int(content)
                            if 1 <= channel_num <= len(text_channels):
                                selected_channel = text_channels[channel_num-1]
                        
                        # If not found by number, try by ID
                        if not selected_channel and content.isdigit():
                            selected_channel = guild.get_channel(int(content))
                            
                        # If still not found, send error
                        if not selected_channel:
                            await message.channel.send("âŒ Oh sweetie, I couldn't find that channel! Please choose a valid channel number or ID. ðŸ’–")
                            return
                            
                        # Store selection and move to next step
                        msg_state["channel_id"] = str(selected_channel.id)
                        msg_state["step"] = "message_input"
                        
                        # Ask for message
                        await message.channel.send(
                            "âœ¨ **Message Creation** âœ¨\n\n"
                            f"Perfect, darling! Now compose your beautiful message to send to **#{selected_channel.name}**.\n\n"
                            "Type your message below. If you want to tag everyone, include @everyone in your message and I'll handle it!"
                        )
                        
                    # Step 3: Message input
                    elif msg_state["step"] == "message_input":
                        if not content:
                            await message.channel.send("âŒ Oh darling, you can't send an empty message! Please type something gorgeous! ðŸ’–")
                            return
                            
                        # Store the message
                        msg_state["message"] = content
                        msg_state["step"] = "ping_selection"
                        
                        # Ask about pings
                        guild = bot.get_guild(int(msg_state["server_id"]))
                        
                        # Create beautiful embed for ping selection
                        embed = discord.Embed(
                            title="ðŸ”” Ping Options ðŸ””",
                            description="Would you like to ping anyone with this message, darling?",
                            color=discord.Color.gold()
                        )
                        
                        embed.add_field(
                            name="ðŸ“‹ Options",
                            value=(
                                "1ï¸âƒ£ **No ping** - Just send the message\n"
                                "2ï¸âƒ£ **@everyone** - Ping everyone in the channel\n"
                                "3ï¸âƒ£ **@here** - Ping only online members\n"
                                "4ï¸âƒ£ **Specific role** - Ping a specific role\n"
                                "5ï¸âƒ£ **Specific user** - Ping an individual user"
                            ),
                            inline=False
                        )
                        
                        embed.set_footer(text="Please enter the number of your choice (1-5)")
                        await message.channel.send(embed=embed)
                        
                    # Step 3.5: Ping selection
                    elif msg_state["step"] == "ping_selection":
                        if not content.isdigit() or int(content) < 1 or int(content) > 5:
                            await message.channel.send("âŒ Please enter a valid option (1-5), sweetheart! ðŸ’–")
                            return
                            
                        option = int(content)
                        guild = bot.get_guild(int(msg_state["server_id"]))
                        
                        # Handle ping selection
                        if option == 1:  # No ping
                            msg_state["ping_target"] = None
                            msg_state["step"] = "confirmation"
                            
                            # Get channel info for confirmation
                            channel = guild.get_channel(int(msg_state["channel_id"]))
                            
                        elif option == 2:  # @everyone
                            msg_state["ping_target"] = "@everyone"
                            msg_state["step"] = "confirmation"
                            
                            # Get channel info for confirmation
                            channel = guild.get_channel(int(msg_state["channel_id"]))
                            
                        elif option == 3:  # @here
                            msg_state["ping_target"] = "@here"
                            msg_state["step"] = "confirmation"
                            
                            # Get channel info for confirmation
                            channel = guild.get_channel(int(msg_state["channel_id"]))
                            
                        elif option == 4:  # Specific role
                            # List roles and ask for selection
                            msg_state["step"] = "role_selection"
                            
                            # Create role selection embed
                            embed = discord.Embed(
                                title="ðŸ‘‘ Role Selection ðŸ‘‘",
                                description=f"Which role in **{guild.name}** would you like to ping?",
                                color=discord.Color.gold()
                            )
                            
                            # Add the first 15 roles to avoid hitting embed limits
                            roles = [role for role in guild.roles if role.mentionable and not role.is_default()]
                            display_roles = roles[:15]
                            
                            for i, role in enumerate(display_roles, 1):
                                embed.add_field(
                                    name=f"{i}: @{role.name}",
                                    value=f"ID: {role.id}",
                                    inline=True
                                )
                                
                            if len(roles) > 15:
                                embed.set_footer(text=f"Showing 15 of {len(roles)} roles. Enter a role number, name, or ID.")
                            else:
                                embed.set_footer(text="Enter the role number, name, or ID")
                                
                            await message.channel.send(embed=embed)
                            return
                            
                        elif option == 5:  # Specific user
                            # List some users and ask for input
                            msg_state["step"] = "user_selection"
                            
                            # Create user selection embed
                            embed = discord.Embed(
                                title="ðŸ‘¤ User Selection ðŸ‘¤",
                                description=f"Which user in **{guild.name}** would you like to ping?",
                                color=discord.Color.gold()
                            )
                            
                            embed.add_field(
                                name="â„¹ï¸ Instructions",
                                value="Please enter the user's ID, username, or nickname.\n\nYou can find a user's ID by enabling Developer Mode in Discord settings, then right-clicking on their name and selecting 'Copy ID'.",
                                inline=False
                            )
                            
                            embed.set_footer(text="Enter a user ID, username, or nickname")
                            await message.channel.send(embed=embed)
                            return
                            
                        # Get server and channel info for confirmation
                        guild = bot.get_guild(int(msg_state["server_id"]))
                        channel = guild.get_channel(int(msg_state["channel_id"]))
                        
                        # Create beautiful confirmation embed
                        embed = discord.Embed(
                            title="ðŸ“ Message Preview ðŸ“",
                            description="Here's a preview of your message, sweetheart!",
                            color=discord.Color.gold()
                        )
                        
                        embed.add_field(
                            name="ðŸ“ Destination",
                            value=f"Server: **{guild.name}**\nChannel: **#{channel.name}**",
                            inline=False
                        )
                        
                        # Show ping information if present
                        if "ping_target" in msg_state and msg_state["ping_target"]:
                            ping_display = msg_state["ping_target"]
                            # Clean up the ping display for prettier output
                            if ping_display.startswith("<@&"):
                                # Role ping
                                role_id = ping_display.replace("<@&", "").replace(">", "")
                                role = discord.utils.get(guild.roles, id=int(role_id))
                                if role:
                                    ping_display = f"@{role.name}"
                            elif ping_display.startswith("<@"):
                                # User ping
                                user_id = ping_display.replace("<@", "").replace(">", "")
                                member = guild.get_member(int(user_id))
                                if member:
                                    ping_display = f"@{member.display_name}"
                                    
                            embed.add_field(
                                name="ðŸ”” Ping",
                                value=f"This message will ping: **{ping_display}**",
                                inline=False
                            )
                            
                        # Truncate message if too long
                        preview = msg_state["message"]
                        if len(preview) > 1000:
                            preview = preview[:997] + "..."
                            
                        embed.add_field(
                            name="ðŸ’Œ Message",
                            value=preview,
                            inline=False
                        )
                        
                        embed.set_footer(text="Type 'send' to send this message, 'edit' to make changes, or 'cancel' to abort")
                        await message.channel.send(embed=embed)
                        
                    # Handle role selection
                    elif msg_state["step"] == "role_selection":
                        guild = bot.get_guild(int(msg_state["server_id"]))
                        selected_role = None
                        
                        # Get all mentionable roles
                        roles = [role for role in guild.roles if role.mentionable and not role.is_default()]
                        
                        # Try to find by number
                        if content.isdigit() and 1 <= int(content) <= len(roles):
                            selected_role = roles[int(content)-1]
                        else:
                            # Try to find by name
                            for role in roles:
                                if role.name.lower() == content.lower() or str(role.id) == content:
                                    selected_role = role
                                    break
                        
                        if not selected_role:
                            await message.channel.send("âŒ I couldn't find that role, sweetie! Please try again with a valid role number, name, or ID. ðŸ’–")
                            return
                        
                        # Save the selected role
                        msg_state["ping_target"] = f"<@&{selected_role.id}>"
                        msg_state["step"] = "confirmation"
                        
                        # Get channel for confirmation
                        channel = guild.get_channel(int(msg_state["channel_id"]))
                        
                        await message.channel.send(f"âœ… I'll ping the **@{selected_role.name}** role with your message, darling!")
                    
                    # Handle user selection
                    elif msg_state["step"] == "user_selection":
                        guild = bot.get_guild(int(msg_state["server_id"]))
                        selected_user = None
                        
                        # Try to find by ID
                        if content.isdigit():
                            selected_user = guild.get_member(int(content))
                        
                        # If not found, try by name
                        if not selected_user:
                            for member in guild.members:
                                if (member.name.lower() == content.lower() or 
                                    (member.nick and member.nick.lower() == content.lower())):
                                    selected_user = member
                                    break
                        
                        if not selected_user:
                            await message.channel.send("âŒ I couldn't find that user, sweetie! Please try again with a valid user ID, username, or nickname. ðŸ’–")
                            return
                        
                        # Save the selected user
                        msg_state["ping_target"] = f"<@{selected_user.id}>"
                        msg_state["step"] = "confirmation"
                        
                        # Get channel for confirmation
                        channel = guild.get_channel(int(msg_state["channel_id"]))
                        
                        await message.channel.send(f"âœ… I'll ping **{selected_user.display_name}** with your message, darling!")
                    
                    # Step 4: Confirmation
                    elif msg_state["step"] == "confirmation":
                        if content.lower() == "send":
                            # Get server and channel
                            guild = bot.get_guild(int(msg_state["server_id"]))
                            if not guild:
                                await message.channel.send("âŒ Oh no, sweetie! Mommy can't find that server anymore! Maybe Mommy got disconnected? ðŸ’”")
                                del active_server_messages[message.author.id]
                                return
                                
                            channel = guild.get_channel(int(msg_state["channel_id"]))
                            if not channel:
                                await message.channel.send("âŒ Oh darling, Mommy can't find that channel anymore! It might have been deleted or Mommy doesn't have access to it! ðŸš«")
                                del active_server_messages[message.author.id]
                                return
                            
                            # Make sure bot has permissions to send messages in this channel
                            bot_member = guild.get_member(bot.user.id)
                            if not channel.permissions_for(bot_member).send_messages:
                                await message.channel.send("âŒ Oh honey! Mommy doesn't have permission to send messages in that channel! Please check Mommy's permissions! ðŸ”’")
                                del active_server_messages[message.author.id]
                                return
                                
                            try:
                                # Send the message, including ping if set
                                if msg_state["ping_target"]:
                                    # Don't need to escape @everyone and @here as Discord.py handles that
                                    if msg_state["ping_target"] in ["@everyone", "@here"]:
                                        # Check if bot has permission to mention everyone
                                        if not channel.permissions_for(bot_member).mention_everyone:
                                            await message.channel.send("âŒ Oh darling! Mommy doesn't have permission to mention everyone in that channel! ðŸ””")
                                            del active_server_messages[message.author.id]
                                            return
                                            
                                        allowed_mentions = discord.AllowedMentions(everyone=True)
                                        complete_message = f"{msg_state['ping_target']} {msg_state['message']}"
                                        
                                        # Check message length before sending
                                        if len(complete_message) > 2000:
                                            await message.channel.send("âŒ Oopsie! Your message is too long (over 2000 characters). Discord has a message length limit. Please edit your message to make it shorter! ðŸ’«")
                                            # Return to message input step to let user revise
                                            msg_state["step"] = "message_input"
                                            return
                                        
                                        await channel.send(complete_message, allowed_mentions=allowed_mentions)
                                    else:
                                        # For user/role pings
                                        complete_message = f"{msg_state['ping_target']} {msg_state['message']}"
                                        
                                        # Check message length before sending
                                        if len(complete_message) > 2000:
                                            await message.channel.send("âŒ Oopsie! Your message is too long (over 2000 characters). Discord has a message length limit. Please edit your message to make it shorter! ðŸ’«")
                                            # Return to message input step to let user revise
                                            msg_state["step"] = "message_input"
                                            return
                                        
                                        # Set allowed mentions for user and role pings
                                        allowed_mentions = discord.AllowedMentions(users=True, roles=True)
                                        await channel.send(complete_message, allowed_mentions=allowed_mentions)
                                else:
                                    # No ping, just send the message
                                    # Check message length before sending
                                    if len(msg_state["message"]) > 2000:
                                        await message.channel.send("âŒ Oopsie! Your message is too long (over 2000 characters). Discord has a message length limit. Please edit your message to make it shorter! ðŸ’«")
                                        # Return to message input step to let user revise
                                        msg_state["step"] = "message_input"
                                        return
                                    
                                    # Send message with no mentions allowed (just to be explicit)
                                    allowed_mentions = discord.AllowedMentions(users=False, roles=False, everyone=False)
                                    await channel.send(msg_state["message"], allowed_mentions=allowed_mentions)
                                
                                # Confirm to user
                                ping_info = f"with {msg_state['ping_target']} mention" if msg_state["ping_target"] else "without any pings"
                                await message.channel.send(
                                    f"âœ… **Message Sent Successfully!** âœ…\n\n"
                                    f"Your message has been delivered to **#{channel.name}** in **{guild.name}** {ping_info}.\n\n"
                                    "Anything else you need help with, darling? ðŸ’–"
                                )
                            except discord.Forbidden:
                                await message.channel.send("âŒ Oh no, sweetie! Mommy doesn't have permission to send messages in that channel! ðŸ”’")
                            except discord.HTTPException as e:
                                await message.channel.send(f"âŒ Oopsie! Something went wrong when sending the message: {str(e)} ðŸ’«")
                                logger.error(f"HTTP error when sending server message: {e}", exc_info=True)
                            except Exception as e:
                                await message.channel.send("âŒ Oh dear, something unexpected happened! Mommy apologizes for the trouble! ðŸŒˆ")
                                logger.error(f"Unexpected error when sending server message: {e}", exc_info=True)
                            finally:
                                # Clean up
                                if message.author.id in active_server_messages:
                                    del active_server_messages[message.author.id]
                            
                        elif content.lower() == "edit":
                            # Go back to message input
                            msg_state["step"] = "message_input"
                            await message.channel.send("ðŸ’« Let's revise that message, darling! Please type your new message now:")
                            
                        elif content.lower() == "cancel":
                            # Cancel the process
                            await message.channel.send("ðŸŒ¸ Message canceled, my precious! Your secret's safe with Mommy! ðŸ’–")
                            del active_server_messages[message.author.id]
                            
                        else:
                            # Invalid input
                            await message.channel.send("â“ Please type 'send', 'edit', or 'cancel', sweetie!")
                            
                except Exception as e:
                    logger.error(f"Error processing server message: {e}", exc_info=True)
                    await message.channel.send(random.choice(MOMMY_ERROR_VARIANTS))
                    if message.author.id in active_server_messages:
                        del active_server_messages[message.author.id]
                    
            # Handle active matches
            elif message.author.id in active_matches:
                try:
                    match_state = active_matches[message.author.id]
                    await process_match_creation_step(match_state, message)
                except Exception as e:
                    logger.error(f"Error processing match creation step: {e}", exc_info=True)
                    await message.channel.send(random.choice(MOMMY_ERROR_VARIANTS))
            # Handle active tryouts
            elif message.author.id in active_tryouts:
                try:
                    # No need to import tryouts here, it's already imported at the top
                    # This was causing a circular import issue
                    player = active_tryouts[message.author.id]["member"]
                    
                    # Create check function for this user's messages
                    def check(m):
                        return m.author.id == message.author.id and isinstance(m.channel, discord.DMChannel)
                    
                    # Process the position selection (first step)
                    if "step" not in active_tryouts[message.author.id]:
                        active_tryouts[message.author.id]["step"] = "position"
                        position = message.content
                        
                        # Validate position input
                        if position not in ["1", "2", "3", "4"]:
                            await message.channel.send("âŒ Please select a valid position (1-4):")
                            await message.channel.send(
                                "> Type `1` for GK (Goalkeeper)\n"
                                "> Type `2` for CM (Central Midfielder)\n"
                                "> Type `3` for LW/RW (Winger)\n"
                                "> Type `4` for CF (Center Forward)"
                            )
                            return
                            
                        # Determine if goalkeeper based on position
                        is_goalkeeper = position == "1"
                        
                        # Store position name for later use
                        position_name = {
                            "1": "GK (Goalkeeper)",
                            "2": "CM (Central Midfielder)",
                            "3": "LW/RW (Winger)",
                            "4": "CF (Center Forward)"
                        }.get(position, "Unknown")
                        
                        logger.info(f"Received position response: {position}, position_name: {position_name}, is_goalkeeper: {is_goalkeeper}")
                        
                        # Save the position info and proceed to skills evaluation
                        active_tryouts[message.author.id]["is_goalkeeper"] = is_goalkeeper
                        active_tryouts[message.author.id]["position"] = position
                        active_tryouts[message.author.id]["position_name"] = position_name
                        active_tryouts[message.author.id]["ratings"] = {}
                        active_tryouts[message.author.id]["step"] = "skills"
                        active_tryouts[message.author.id]["current_skill"] = 0
                        
                        # Send skills evaluation introduction
                        await asyncio.sleep(1)  # Brief pause for readability
                        await message.channel.send(
                            "**ðŸŽ¯ Player Skills Evaluation**\n\n"
                            "Let's rate their skills on a scale from 0 to 10!\n"
                            "For each skill, please enter a number between 0 and 10."
                        )
                        
                        # Send first skill prompt
                        skills = [
                            ('shooting', 'âš½ Rate their shooting ability (0-10):'),
                            ('dribbling', 'ðŸ‘Ÿ Rate their dribbling ability (0-10):'),
                            ('passing', 'ðŸŽ¯ Rate their passing ability (0-10):'),
                            ('defense', 'ðŸ›¡ï¸ Rate their defensive ability (0-10):'),
                            ('goalkeeping', 'ðŸ§¤ Rate their goalkeeping ability (0-10) or type "skip":')
                        ]
                        
                        skill_name, prompt = skills[0]
                        await message.channel.send(f"**{prompt}**")
                        return
                    
                    # Process skills ratings
                    if active_tryouts[message.author.id]["step"] == "skills":
                        skills = [
                            ('shooting', 'âš½ Rate their shooting ability (0-10):'),
                            ('dribbling', 'ðŸ‘Ÿ Rate their dribbling ability (0-10):'),
                            ('passing', 'ðŸŽ¯ Rate their passing ability (0-10):'),
                            ('defense', 'ðŸ›¡ï¸ Rate their defensive ability (0-10):'),
                            ('goalkeeping', 'ðŸ§¤ Rate their goalkeeping ability (0-10) or type "skip":')
                        ]
                        
                        # Get the current skill index, ensure it's valid
                        current_skill = active_tryouts[message.author.id].get("current_skill", 0)
                        if current_skill >= len(skills):
                            # We've already processed all skills, finalize evaluation
                            logger.warning(f"Attempted to process skill index {current_skill} but only {len(skills)} skills exist")
                            # Skip to finalizing evaluation
                            active_tryouts[message.author.id]["step"] = "finalizing"
                        else:
                            # Process the current skill
                            skill_name, _ = skills[current_skill]
                            
                            # Process current skill rating
                            if skill_name == "goalkeeping" and message.content.lower() == "skip":
                                active_tryouts[message.author.id]["ratings"][skill_name] = None
                                logger.info(f"Goalkeeping rating skipped for {player}")
                            else:
                                try:
                                    rating = int(message.content)
                                    if 0 <= rating <= 10:
                                        active_tryouts[message.author.id]["ratings"][skill_name] = rating
                                        logger.info(f"Received valid {skill_name} rating: {rating} for {player}")
                                    else:
                                        await message.channel.send("âŒ Please enter a number between 0 and 10!")
                                        return
                                except ValueError:
                                    await message.channel.send("âŒ Please enter a valid number!")
                                    return
                            
                            # Move to next skill or finalize evaluation
                            active_tryouts[message.author.id]["current_skill"] += 1
                            next_skill = active_tryouts[message.author.id]["current_skill"]
                            
                            # Create evaluation dict outside the if/else block to avoid scope issues
                            is_goalkeeper = active_tryouts[message.author.id]["is_goalkeeper"]
                            position_name = active_tryouts[message.author.id]["position_name"]
                            ratings = active_tryouts[message.author.id]["ratings"]
                            
                            evaluation = {
                                "ratings": ratings,
                                "feedback": "Player evaluation completed.",
                                "is_goalkeeper": is_goalkeeper,
                                "position_name": position_name
                            }
                            
                            if next_skill < len(skills):
                                # Ask for next skill
                                skill_name, prompt = skills[next_skill]
                                await message.channel.send(f"**{prompt}**")
                                return  # Exit here, don't process the evaluation yet
                            else:
                                # Set step to finalizing to avoid index errors on next message
                                active_tryouts[message.author.id]["step"] = "finalizing"
                                # Continue with evaluation (fall through to code below)
                            
                            # Continue with the evaluation process
                            # Import server configuration
                            from server_config import get_channel_id
                            
                            # Get the player from the tryout state
                            player = active_tryouts[message.author.id]["member"]
                            server_id = active_tryouts[message.author.id]["server_id"]
                            guild = active_tryouts[message.author.id]["guild"]
                            
                            # Calculate player value
                            player_eval = PlayerEvaluation(
                                ratings=evaluation["ratings"],
                                feedback=evaluation["feedback"],
                                is_goalkeeper=evaluation["is_goalkeeper"],
                                position_name=evaluation["position_name"]
                            )
                            value = player_eval.calculate_value()
                            
                            # Get the tryout results channel
                            tryouts_channel_id = get_channel_id("tryout_results", server_id)
                            tryouts_channel = None
                            player_values_channel = None

                            # Try to get the tryout results channel
                            if tryouts_channel_id and tryouts_channel_id.isdigit():
                                tryouts_channel = guild.get_channel(int(tryouts_channel_id))
                            
                            # Try to get the player values channel
                            player_values_channel_id = get_channel_id("values", server_id)
                            if player_values_channel_id and player_values_channel_id.isdigit():
                                player_values_channel = guild.get_channel(int(player_values_channel_id))
                            
                            # Create the evaluation message
                            results_message = (
                                f"# ðŸ“Š Player Evaluation Results\n\n"
                                f"## {player.mention} as {evaluation['position_name']}\n\n"
                                f"**Rating Details:**\n"
                                f"âš½ Shooting: {evaluation['ratings'].get('shooting', 'N/A')}/10\n"
                                f"ðŸ‘Ÿ Dribbling: {evaluation['ratings'].get('dribbling', 'N/A')}/10\n"
                                f"ðŸŽ¯ Passing: {evaluation['ratings'].get('passing', 'N/A')}/10\n"
                                f"ðŸ›¡ï¸ Defense: {evaluation['ratings'].get('defense', 'N/A')}/10\n"
                                f"ðŸ§¤ Goalkeeping: {evaluation['ratings'].get('goalkeeping', 'N/A')}/10\n\n"
                                f"ðŸ’° **Calculated Value:** Â¥{value}m"
                            )
                            
                            # Post in tryouts channel if available
                            if tryouts_channel:
                                await tryouts_channel.send(results_message)
                                logger.info(f"[TRYOUTS] Posted results in tryout results channel for {player}")
                            else:
                                # Fallback to the evaluator's DM channel
                                await message.channel.send("âš ï¸ Tryouts results channel not found. Posting results here:")
                                await message.channel.send(results_message)
                                logger.warning(f"[TRYOUTS] Could not find tryouts channel for server {server_id}")
                            
                            # Post in player values channel if available
                            if player_values_channel:
                                await player_values_channel.send(f"{player.mention}, your player value has been set to Â¥{value} million! ðŸ’°")
                                logger.info(f"[TRYOUTS] Posted value update in player values channel")
                            
                            # Set the player's value in the data manager
                            member_id = str(player.id)
                            data_manager.set_member_value(member_id, value)
                            logger.info(f"[TRYOUTS] Set player {member_id} value to {value}")
                            
                            # Update player roles
                            try:
                                # Remove tryout role and add regular player role
                                tryout_role_id = 1350864967674630144  # Tryout Squad role
                                player_role_id = 1350863646187716640  # Regular Player role
                                
                                # Get role objects
                                tryout_role = discord.utils.get(guild.roles, id=tryout_role_id)
                                player_role = discord.utils.get(guild.roles, id=player_role_id)
                                
                                if tryout_role and player_role:
                                    # Remove tryout role
                                    if tryout_role in player.roles:
                                        await player.remove_roles(tryout_role)
                                        logger.info(f"[TRYOUTS] Removed tryout role from {player.id}")
                                    
                                    # Add player role
                                    await player.add_roles(player_role)
                                    logger.info(f"[TRYOUTS] Added player role to {player.id}")
                                else:
                                    logger.error(f"[TRYOUTS] Could not find roles: tryout_role={tryout_role}, player_role={player_role}")
                            except Exception as e:
                                logger.error(f"[TRYOUTS] Error updating roles: {e}", exc_info=True)
                            
                            # Notify the player if configured - only send from on_message handler, not from tryoutsresults_cmd
                            from_command = active_tryouts[message.author.id].get("from_command", False)
                            if not from_command:  # Only send DM if not initiated via tryoutsresults_cmd
                                try:
                                    player_dm = await player.create_dm()
                                    await player_dm.send(
                                        f"# ðŸŽ‰ Your Evaluation is Complete!\n\n"
                                        f"Darling, Mommy has the results of your evaluation! ðŸ’–\n\n"
                                        f"Your value has been set to **Â¥{value} million**!\n\n"
                                        f"Check the tryouts channel to see your full evaluation! ðŸ“‹"
                                    )
                                    logger.info(f"[TRYOUTS] Sent completion DM to player {member_id}")
                                except Exception as e:
                                    logger.warning(f"[TRYOUTS] Failed to send DM to player {member_id}: {e}")
                            else:
                                logger.info(f"[TRYOUTS] Skipped sending completion DM to player {member_id} (tryout initiated via command)")
                            
                            # Delete the active tryout
                            del active_tryouts[message.author.id]
                            
                            # Confirm to the evaluator
                            await message.channel.send(
                                "âœ… **Evaluation Complete!**\n\n"
                                f"Mommy has posted the results in the tryouts channel and set {player.mention}'s value to Â¥{value} million!\n\n"
                                "Thank you for helping evaluate our players, darling! ðŸ’‹"
                            )
                            
                        return

                except Exception as e:
                    logger.error(f"Error processing tryout evaluation step: {e}", exc_info=True)
                    await message.channel.send(random.choice(MOMMY_ERROR_VARIANTS))
        
        # CRITICAL SECTION: Simply block any duplicate message processing without complex file operations
        # Cache approach is unreliable and leads to race conditions when process respawns
        message_details = f"ID:{message.id}, Content:'{message.content[:30]}...', From:{message.author.name}"
        
        # Process ID for this running instance
        current_pid = os.getpid()
        
        # Ensure we have a processed messages dictionary
        if not hasattr(bot, "_processed_messages"):
            bot._processed_messages = {}
            logger.info(f"Initialized _processed_messages tracking dictionary for PID: {current_pid}")
        
        # Check if we're processing a command
        is_command = message.content.startswith(COMMAND_PREFIX)
            
        # Ultra-simplification: Use string message IDs as keys (just to be safe)
        message_id_str = str(message.id)
        
        # CHECK #1: Is this message already processed by this instance?
        if message_id_str in bot._processed_messages:
            processed_data = bot._processed_messages[message_id_str]
            time_ago = time.time() - processed_data.get('timestamp', 0)
            original_pid = processed_data.get('pid', 'unknown')
            
            # Only log warnings for command messages to reduce noise
            if is_command:
                logger.warning(
                    f"[DUPLICATE-INSTANCE] Message {message.id} already processed {time_ago:.2f}s ago "
                    f"by PID:{original_pid}, current PID:{current_pid}, content:'{message.content[:30]}...'"
                )
            return  # Skip processing entirely
        
        # Mark the message as processed immediately to avoid duplicate processing
        current_time = time.time()
        bot._processed_messages[message_id_str] = {
            'timestamp': current_time,
            'pid': current_pid,
            'is_command': is_command
        }
        
        # Process the command - this is the only place in our code that should call process_commands
        logger.info(f"[PROCESSING] {message_details} with PID {current_pid}")
        
        try:
            await bot.process_commands(message)
            
            # Cleanup old messages occasionally to prevent memory leak (keep only last 1000 messages)
            if len(bot._processed_messages) > 1000:
                # Remove oldest entries - use cutoff time rather than count for safety
                cutoff_time = time.time() - 3600  # 1 hour ago
                keys_to_delete = []
                for msg_id, data in bot._processed_messages.items():
                    msg_time = data.get('timestamp', 0)
                    if msg_time < cutoff_time:
                        keys_to_delete.append(msg_id)
                
                # Delete the old messages
                for key in keys_to_delete:
                    del bot._processed_messages[key]
                
                if keys_to_delete:  # Only log if we actually deleted something
                    logger.debug(f"Cleaned up {len(keys_to_delete)} old message entries (older than 1 hour)")
        except Exception as e:
            logger.error(f"Error processing message: {e}", exc_info=True)
    except Exception as e:
        logger.error(f"Error in on_message event: {e}", exc_info=True)

@bot.event
async def on_member_join(member):
    # Update last heartbeat on every member join event
    global last_heartbeat
    last_heartbeat = time.time()
    
    try:
        # Get server-specific configuration
        from server_config import get_new_member_role_id, get_server_config, get_channel_id, get_role_id, get_server_name
        
        server_id = str(member.guild.id)
        logger.info(f"New member {member.id} joined server {server_id}")
        
        # Get the server config
        server_config = get_server_config(server_id)
        if not server_config:
            logger.warning(f"No configuration found for server {server_id}, using defaults")
            
        server_name = get_server_name(server_id)
        
        # Assign the default new member role if configured
        new_member_role_id = get_new_member_role_id(server_id)
        if new_member_role_id:
            try:
                new_member_role = discord.utils.get(member.guild.roles, id=int(new_member_role_id))
                if new_member_role:
                    await member.add_roles(new_member_role)
                    logger.info(f"Added new member role {new_member_role.name} to {member.id} in server {server_id}")
                else:
                    logger.warning(f"New member role with ID {new_member_role_id} not found in server {server_id}")
            except Exception as e:
                logger.error(f"Error adding new member role: {e}", exc_info=True)
        
        # Send welcome message if welcome channel is configured
        welcome_channel = None
        welcome_channel_id = get_channel_id("welcome", server_id)
        
        if welcome_channel_id and welcome_channel_id.isdigit():
            # If it's an ID, get the channel by ID
            welcome_channel = member.guild.get_channel(int(welcome_channel_id))
        else:
            # Try to find by name if not found by ID
            welcome_channel_name = welcome_channel_id or "welcome"
            welcome_channel = discord.utils.get(member.guild.text_channels, name=welcome_channel_name)
        
        if welcome_channel:
            # Check if server uses professional or sassy language
            from server_config import uses_sassy_language
            use_sassy = uses_sassy_language(server_id)
            
            if use_sassy:
                # Use randomized sassy welcome messages
                welcome_messages = [
                    f"ðŸ’ž Welcome, my precious {server_name} member, {member.mention}! Mommy is so proud to have you here!",
                    f"ðŸ’– Aww, look who just joined! Welcome, {member.mention}! Let's make some magic together, darling!",
                    f"âœ¨ Oh, my sweet {member.mention}, welcome to {server_name}! Mommy is excited to see you shine!",
                    f"ðŸŒŸ Greetings, darling {member.mention}! You are now part of the {server_name} familyâ€”time to show your brilliance!",
                    f"ðŸ’ Hello, lovely {member.mention}! Welcome to {server_name}, where every member is cherished, sweetie!"
                ]
            else:
                # Use randomized professional welcome messages
                welcome_messages = [
                    f"ðŸ‘‹ Welcome to {server_name}, {member.mention}! We're glad to have you here.",
                    f"âœ¨ Welcome, {member.mention}! Thank you for joining {server_name}.",
                    f"ðŸŽ‰ {member.mention} has joined {server_name}! Welcome to the community.",
                    f"ðŸ“£ Please welcome our newest member, {member.mention}, to {server_name}!",
                    f"ðŸŒŸ {server_name} welcomes {member.mention}! We look forward to your contributions."
                ]
                
            welcome_message = random.choice(welcome_messages)
            await welcome_channel.send(welcome_message)
            logger.info(f"Sent welcome message for {member.id} in server {server_id}")
        else:
            logger.warning(f"Welcome channel not found for server {server_id}")
    except Exception as e:
        logger.error(f"Error in on_member_join: {e}", exc_info=True)



def cleanup():
    """Perform any cleanup tasks before shutdown with ultra-reliability focus."""
    global bot_instance_claimed
    
    try:
        # Use centralized instance management for releasing resources
        logger.info("Performing bot cleanup with enhanced reliability checks...")
        
        # Remove any runtime lock files
        try:
            if os.path.exists("bot_running.lock"):
                os.remove("bot_running.lock")
                logger.info("Removed bot_running.lock during cleanup")
        except Exception as lock_err:
            logger.warning(f"Failed to remove running lock during cleanup: {lock_err}")
            
        # Make sure we're not keeping the process alive with env var
        try:
            if "DISCORDSDK_PROCESS_ID" in os.environ:
                del os.environ["DISCORDSDK_PROCESS_ID"]
                logger.info("Cleared DISCORDSDK_PROCESS_ID environment variable")
        except Exception as env_err:
            logger.warning(f"Failed to clear environment variable: {env_err}")
            
        # Release instance using instance manager
        try:
            release_instance(BOT_PID_FILE)
            bot_instance_claimed = False
            logger.info("Released bot instance in cleanup function")
        except Exception as release_err:
            logger.warning(f"Failed to release instance during cleanup: {release_err}")
        
        # For backward compatibility, still run the old lock file removal
        try:
            remove_lock_files()
            logger.info("Removed legacy lock files")
        except Exception as lock_removal_err:
            logger.warning(f"Error removing lock files: {lock_removal_err}")
        
        # Cleanly cancel asyncio tasks if we're in an event loop
        try:
            loop = asyncio.get_event_loop() if asyncio.get_event_loop().is_running() else None
            if loop:
                tasks = [t for t in asyncio.all_tasks(loop=loop) if t is not asyncio.current_task(loop=loop)]
                if tasks:
                    logger.info(f"Cancelling {len(tasks)} remaining asyncio tasks")
                    for task in tasks:
                        task.cancel()
        except Exception as task_err:
            logger.warning(f"Failed to cancel asyncio tasks: {task_err}")
            
        logger.info("Cleanup completed successfully, darling!")
    except Exception as e:
        logger.error(f"Error during cleanup: {e}")

def start_bot_background():
    """Starts the Discord bot. This call is blocking so run it in a separate thread."""
    try:
        # Get or create event loop
        try:
            loop = asyncio.get_event_loop()
        except RuntimeError:
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
        
        # Define async startup with the @safe_task decorator to ensure proper task context
        from timeout_handlers import safe_task
        
        @safe_task
        async def start_bot():
            try:
                async with bot:
                    await bot.start(TOKEN)  # Removed reconnect=True parameter to fix intents error
            except ConnectionClosedError as e:
                # Explicitly catch ConnectionClosedError if we imported it successfully
                logger.warning(f"Websocket connection closed unexpectedly: {e}")
                logger.info("Will automatically attempt to reconnect...")
                # The bot should automatically reconnect based on intents configuration
                # But we'll add a small delay to prevent rapid reconnection attempts
                await asyncio.sleep(5)
            except Exception as e:
                # Fallback to string checking if the import failed
                if ConnectionClosedError is None and "ConnectionClosedError" in str(type(e)):
                    logger.warning(f"Websocket connection closed (string match): {e}")
                    logger.info("Will automatically attempt to reconnect...")
                    await asyncio.sleep(5)
                else:
                    logger.critical(f"Bot startup failed: {e}")
                    raise
        
        # Schedule the bot startup and run forever
        loop.create_task(start_bot())
        loop.run_forever()
    except Exception as e:
        logger.critical(f"Bot encountered an error: {e}")
        raise

def keep_alive_and_run_bot():
    """Start both the Flask web server and the Discord bot with ultra-reliable design for zero downtime"""
    
    # Variables to track retry attempts and last error
    max_retries = 10  # Maximum number of immediate retries
    retry_count = 0
    last_error = None
    backoff_time = 5  # Start with 5 seconds, will increase with each retry
    max_backoff = 300  # Maximum 5 minutes between retries
    
    # Create error log file with timestamp
    error_log_file = f"bot_errors.log"
    error_logger = logging.getLogger("bot_errors")
    error_logger.setLevel(logging.ERROR)
    # Check if handler already exists to prevent duplicate handlers
    if not error_logger.handlers:
        error_handler = logging.FileHandler(error_log_file)
        error_handler.setFormatter(logging.Formatter('%(asctime)s - %(message)s'))
        error_logger.addHandler(error_handler)
    
    # Check if a bot instance is currently running and responding
    # Import our new task wrapper utilities
    from task_wrapper import ensure_task, safe_timeout
    
    @ensure_task
    async def check_bot_health_async():
        """Check if the bot is properly responding to its health endpoint with proper task context"""
        try:
            # Use aiohttp instead of requests for async operation
            import aiohttp
            async with safe_timeout(3.0):
                async with aiohttp.ClientSession() as session:
                    async with session.get("http://localhost:5001/healthz") as response:
                        if response.status == 200:
                            data = await response.json()
                            bot_pid = data.get("pid")
                            # Verify that the process is still alive
                            if bot_pid and psutil.pid_exists(bot_pid):
                                logger.info(f"Found healthy bot instance running with PID {bot_pid}")
                                return True
                        return False
        except Exception as e:
            logger.error(f"Error checking bot health: {e}")
            return False
    
    def is_bot_responding():
        """Synchronous wrapper for async bot health check"""
        try:
            # Try to connect to the Flask health endpoint
            import requests
            response = requests.get("http://localhost:5001/healthz", timeout=3)
            if response.status_code == 200:
                data = response.json()
                bot_pid = data.get("pid")
                # Verify that the process is still alive
                if bot_pid and psutil.pid_exists(bot_pid):
                    logger.info(f"Found healthy bot instance running with PID {bot_pid}")
                    return True
            return False
        except Exception:
            return False
    
    # If an instance is already running and responding, exit
    if is_bot_responding():
        logger.info("Bot is already running and responding to health checks. Exiting to prevent duplicates.")
        return
    
    # Kill any potentially dead or zombie bot processes
    try:
        killed_pids = kill_other_instances("python.*bot\.py", force=True)
        if killed_pids:
            logger.info(f"Killed stale bot processes: {killed_pids}")
            time.sleep(2)  # Give processes time to fully terminate
    except Exception as e:
        logger.warning(f"Error when trying to kill stale processes: {e}")
    
    # Main retry loop - will continue retrying indefinitely with exponential backoff
    while True:
        bot_instance_claimed = False
        try:
            # Use centralized instance manager to check for running instances
            if not claim_instance(BOT_PID_FILE, "bot.py"):
                logger.error(f"Bot already running with PID in {BOT_PID_FILE}, exiting to prevent duplicates.")
                # Check if the PID file is stale before giving up
                try:
                    with open(BOT_PID_FILE, 'r') as f:
                        pid = int(f.read().strip())
                    if not psutil.pid_exists(pid):
                        logger.warning(f"Found stale PID file for non-existent process {pid}. Removing.")
                        os.remove(BOT_PID_FILE)
                        # Continue to next iteration to try claiming again
                        continue
                except (FileNotFoundError, ValueError, PermissionError) as e:
                    logger.warning(f"Error checking PID file: {e}")
                
                # If we reach here, there's a real running instance
                time.sleep(30)
                continue
            
            bot_instance_claimed = True
            # We've successfully claimed the instance
            logger.info(f"Bot claimed instance with PID: {os.getpid()} using improved instance management")
            
            # Write PID to separate debug file to help with monitoring
            debug_pid = os.getpid()
            logger.debug(f"Bot initialization with process ID: {debug_pid}")
            
            # Start the Flask web server in a separate thread    
            keep_alive()
            logger.info("Flask web server started on port 5001, darling!")
            
            # Make sure web server is up before continuing
            time.sleep(1)
            
            # Reset retry count upon successful start
            retry_count = 0
            backoff_time = 5
            
            try:
                # First, ensure we have a valid token
                if not TOKEN:
                    # Re-import config to force token refresh
                    try:
                        logger.warning("TOKEN is missing, attempting emergency token retrieval")
                        from importlib import reload
                        import config as config_module
                        reload(config_module)
                        clean_token_final = config_module.TOKEN
                        if not clean_token_final:
                            raise ValueError("Failed to retrieve token after reload")
                    except Exception as token_err:
                        logger.critical(f"Emergency token retrieval failed: {token_err}")
                        # Try environment directly as last resort
                        clean_token_final = os.environ.get("DISCORD_TOKEN", "")
                        if not clean_token_final:
                            raise ValueError("No token available from any source")
                else:
                    # We have a token, apply final cleaning
                    clean_token_final = TOKEN
                
                # Extra safety cleaning for token format issues
                if isinstance(clean_token_final, str):
                    # Strip quotes and whitespace
                    clean_token_final = clean_token_final.strip().strip('"\'')
                    
                    # Handle escape sequences
                    if '\\' in clean_token_final:
                        try:
                            clean_token_final = clean_token_final.encode().decode('unicode_escape')
                            logger.info("Successfully decoded escape sequences in token")
                        except Exception as e:
                            logger.warning(f"Failed to decode escape sequences: {e}")
                    
                    # Extract core token if embedded in larger string
                    token_match = re.search(r'[A-Za-z0-9_\-\.]{59,100}', clean_token_final)
                    if token_match:
                        extracted = token_match.group(0)
                        if extracted != clean_token_final:
                            logger.info("Extracted token from larger string")
                            clean_token_final = extracted
                
                logger.info(f"Starting bot with token of length: {len(clean_token_final) if clean_token_final else 0}")
                
                # Fix for "Timeout context manager should be used inside a task" error
                # Use bot.run() which properly sets up the event loop and task context
                logger.info("Starting Discord bot using bot.run() method - this will properly initialize the asyncio environment")
                
                # Wait for any previous event loops to properly shut down
                time.sleep(1)
                
                # Run the bot with enhanced error handling - critical point!
                # In discord.py 2.5.2, there's an issue with intents detection if we pass certain kwargs
                # Simplify the call to avoid the "property 'intents' of 'Bot' object has no setter" error
                logger.info("Avoiding intents error by using simplified bot.run call")
                
                # CRITICAL CHANGE: This call blocks until bot.close() is called or an exception is raised
                # Create a lock file to indicate bot is running properly
                try:
                    with open("bot_running.lock", "w") as lock_file:
                        lock_file.write(f"{os.getpid()}")
                except Exception as lock_err:
                    logger.warning(f"Failed to create running lock file: {lock_err}")
                
                # Set discordsdk_process_id to current process ID for potential recovery
                os.environ["DISCORDSDK_PROCESS_ID"] = str(os.getpid())
                
                # Run with enhanced parameters for stability
                # log_handler=None - Prevent duplicate log handlers
                # log_level=logging.INFO - Avoid excessive debug logging from discord.py internals
                # Removed reconnect=True parameter to fix intents error in discord.py 2.5.2
                
                # Additional token validation before run
                if not clean_token_final or len(clean_token_final) < 59:
                    logger.critical(f"Invalid token format detected before bot.run() - length: {len(clean_token_final) if clean_token_final else 0}")
                    # Try to reload token from environment
                    logger.info("Attempting emergency token reload before bot.run()")
                    try:
                        from dotenv import load_dotenv
                        load_dotenv(force=True)
                        emergency_token = os.getenv("DISCORD_TOKEN")
                        if emergency_token and len(emergency_token.strip()) >= 59:
                            clean_token_final = emergency_token.strip()
                            logger.info(f"Emergency token loaded with length: {len(clean_token_final)}")
                    except Exception as token_err:
                        logger.error(f"Emergency token reload failed: {token_err}")
                
                # Run the bot with the validated token
                # CRITICAL FIX: In discord.py 2.5.2, there's a bug with how parameters are passed to bot.run
                # Pass ONLY the token to avoid "property 'intents' of 'Bot' object has no setter" error
                # Enhanced reliability: log that we're executing the patched bot.run method
                logger.info("Running discord.py bot with simplified parameters to avoid intents error")
                try:
                    # Run with proper async context
                    bot.run(clean_token_final)
                except RuntimeError as e:
                    if "Timeout context manager" in str(e):
                        logger.error(f"Timeout context manager error: {e}")
                        logger.info("Attempting recovery with proper task context")
                        # Force proper task context for recovery
                        from timeout_handlers import ensure_proper_startup
                        # Define a wrapper to start the bot with proper task context
                        @ensure_proper_startup
                        async def start_bot_proper_context():
                            await bot.start(clean_token_final)
                        # Run the bot with proper startup wrapper
                        start_bot_proper_context()
                    else:
                        raise  # Re-raise if it's not the timeout context error
                
                # If bot.run() returns normally (should only happen on clean shutdown)
                logger.info("Bot.run() completed normally - likely due to intentional shutdown")
                
                # Clean up lock file
                try:
                    if os.path.exists("bot_running.lock"):
                        os.remove("bot_running.lock")
                except Exception as unlock_err:
                    logger.warning(f"Failed to remove running lock file: {unlock_err}")
                
                cleanup()
                break  # Exit the retry loop only on intentional shutdown
                
            except discord.errors.HTTPException as e:
                error_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                error_logger.error(f"HTTP error: {e}")
                
                if e.status == 429:  # Rate limit error
                    logger.critical(f"Discord rate limit hit: {e} - implementing exponential backoff")
                    # Rate limits require longer backoff
                    last_error = f"{error_time} - Rate limit error: {e}"
                    retry_count += 1
                    time.sleep(min(backoff_time * 2, 300))  # Up to 5 minutes
                else:
                    logger.critical(f"Discord HTTP error: {e}")
                    last_error = f"{error_time} - HTTP error: {e}"
                    retry_count += 1
                
            except discord.errors.LoginFailure as e:
                error_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                error_logger.error(f"Authentication failed: {e}")
                
                logger.critical(f"Discord login failed (token issue): {e}")
                # Force token refresh on next attempt
                try:
                    with open("refresh_token_cache", "w") as f:
                        f.write(str(time.time()))
                    logger.info("Created refresh_token_cache flag to force token refresh")
                except Exception as write_err:
                    logger.warning(f"Failed to create token refresh flag: {write_err}")
                
                # Try to get new token directly from environment
                try:
                    new_token = os.environ.get("DISCORD_TOKEN", "")
                    if new_token and new_token != clean_token_final:
                        logger.info("Found new token in environment, will use on next attempt")
                except Exception:
                    pass
                
                last_error = f"{error_time} - Authentication failed: {e}"
                retry_count += 1
                time.sleep(backoff_time)
                
            except Exception as e:
                error_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                
                # Special handling for ConnectionClosedError from websockets
                if ConnectionClosedError is not None and isinstance(e, ConnectionClosedError):
                    error_logger.warning(f"ConnectionClosedError: {e}")
                    logger.warning(f"Websocket connection closed: {e}")
                    last_error = f"{error_time} - Connection closed: {e}"
                    # Using shorter delay for connection errors since they often recover quickly
                    time.sleep(3)
                    
                # Fallback string matching for ConnectionClosedError if we couldn't import it directly
                elif "ConnectionClosed" in str(type(e)) or "ConnectionClosedError" in str(type(e)):
                    error_logger.warning(f"ConnectionClosed error (string match): {e}")
                    logger.warning(f"Websocket connection closed (string match): {e}")
                    last_error = f"{error_time} - Connection closed: {e}"
                    # Using shorter delay for connection errors since they often recover quickly
                    time.sleep(3)
                    
                # General exception handling for all other errors
                else:
                    error_logger.error(f"Unexpected error: {e}")
                    error_logger.error(traceback.format_exc())
                    logger.critical(f"Unexpected error in bot.run(): {e}", exc_info=True)
                    last_error = f"{error_time} - Unexpected error: {e}"
                    retry_count += 1
                
            finally:
                # Always clean up resources, especially event loop and asyncio state
                try:
                    # Remove running lock file immediately to prevent instance confusion
                    if os.path.exists("bot_running.lock"):
                        os.remove("bot_running.lock")
                        logger.info("Removed bot_running.lock in finally block")
                except Exception as lock_err:
                    logger.warning(f"Failed to remove lock file in finally: {lock_err}")
                
                # Cancel all running tasks to prevent lingering tasks from blocking new instance
                try:
                    # Get all tasks from the current event loop
                    loop = asyncio.get_event_loop() if asyncio.get_event_loop().is_running() else None
                    if loop:
                        tasks = asyncio.all_tasks(loop=loop) if hasattr(asyncio, 'all_tasks') else asyncio.Task.all_tasks(loop=loop)
                        for task in tasks:
                            if task != asyncio.current_task(loop=loop):
                                task.cancel()
                        
                        # Wait a moment for tasks to actually cancel
                        logger.debug(f"Waiting for {len(tasks)} tasks to cancel")
                        try:
                            # Use run_until_complete with a short timeout to allow tasks to cancel
                            pending_tasks = [t for t in tasks if not t.done() and t != asyncio.current_task(loop=loop)]
                            if pending_tasks:
                                wait_task = asyncio.gather(*pending_tasks, return_exceptions=True)
                                loop.run_until_complete(wait_for_safe(wait_task, 2.0))
                        except (asyncio.CancelledError, asyncio.TimeoutError, Exception) as wait_err:
                            logger.debug(f"Task cancellation wait completed: {wait_err}")
                except Exception as task_err:
                    logger.warning(f"Error during task cleanup: {task_err}")
                
                # Always release the instance and clean up
                cleanup()
                if bot_instance_claimed:
                    try:
                        release_instance(BOT_PID_FILE)
                        bot_instance_claimed = False
                        logger.info("Successfully released bot instance in finally block")
                    except Exception as e:
                        logger.error(f"Failed to release instance: {e}")
            
            # Implement exponential backoff, but keep trying forever
            backoff_time = min(backoff_time * 1.5, max_backoff)
            logger.warning(f"Retry {retry_count} - Waiting {backoff_time:.1f}s before next attempt. Last error: {last_error}")
            time.sleep(backoff_time)
            
        except Exception as outer_e:
            # If we get here, something went very wrong with the restart logic itself
            error_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            error_logger.critical(f"Critical error in restart loop: {outer_e}")
            error_logger.critical(traceback.format_exc())
            
            logger.critical(f"Critical error in bot restart logic: {outer_e}", exc_info=True)
            
            # Always try to release the instance if we claimed it
            if bot_instance_claimed:
                try:
                    release_instance(BOT_PID_FILE)
                    bot_instance_claimed = False
                except Exception:
                    pass
            
            # Sleep before retrying to avoid tight restart loops
            time.sleep(60)  # 1 minute cooldown on critical errors

@bot.command(name='addvalue')
async def add_value_cmd(ctx, member: discord.Member, amount: int):
    try:
        if not has_management_role(ctx.author):
            await ctx.send(random.choice(MOMMY_PERMISSION_DENIED))
            return
        
        # Get member ID as string - this is common across all servers
        member_id = str(member.id)
        
        # Get current value and update it
        current_value = data_manager.get_member_value(member_id)
        new_value = current_value + amount
        data_manager.set_member_value(member_id, new_value)
        
        # Handle Novera specific role assignments
        if ctx.guild and str(ctx.guild.id) == "1350165280940228629":  # Novera server ID
            try:
                # Role IDs for Novera server
                verified_role_id = 1350864967674630144  # Role to remove
                noverian_role_id = 1350863646187716640  # Role to add
                
                # Get the role objects
                verified_role = ctx.guild.get_role(verified_role_id)
                noverian_role = ctx.guild.get_role(noverian_role_id)
                
                # Remove verified role if member has it
                if verified_role and verified_role in member.roles:
                    await member.remove_roles(verified_role)
                    logger.info(f"Removed verified role from {member.id} in Novera server")
                
                # Add Noverian role if member doesn't have it
                if noverian_role and noverian_role not in member.roles:
                    await member.add_roles(noverian_role)
                    logger.info(f"Added Noverian role to {member.id} in Novera server")
            except Exception as role_error:
                logger.error(f"Error managing roles in addvalue command: {role_error}", exc_info=True)
                # Continue anyway since the main functionality is updating the value
        
        # Post in current channel and also in the values channel if configured
        await ctx.send(f"âœ… Darling, {member.mention}'s value has been increased by Â¥{amount} million! Their new value is Â¥{new_value} million! {random.choice(MOMMY_SUCCESS_VARIANTS)}")
        
        # Log which server the command was used in
        logger.info(f"User {ctx.author.id} added {amount} to {member_id}'s value in server {ctx.guild.id if ctx.guild else 'DM'}")
    except Exception as e:
        logger.error(f"Error in addvalue command: {e}", exc_info=True)
        await ctx.send(random.choice(MOMMY_ERROR_VARIANTS))

@bot.command(name='setvalue')
async def set_value_cmd(ctx, member: discord.Member, amount: int):
    try:
        if not has_management_role(ctx.author):
            await ctx.send(random.choice(MOMMY_PERMISSION_DENIED))
            return
        
        # Get member ID as string - this is common across all servers
        member_id = str(member.id)
        
        # Set the new value
        data_manager.set_member_value(member_id, amount)
        
        # Handle Novera specific role assignments
        if ctx.guild and str(ctx.guild.id) == "1350165280940228629":  # Novera server ID
            try:
                # Role IDs for Novera server
                verified_role_id = 1350864967674630144  # Role to remove
                noverian_role_id = 1350863646187716640  # Role to add
                
                # Get the role objects
                verified_role = ctx.guild.get_role(verified_role_id)
                noverian_role = ctx.guild.get_role(noverian_role_id)
                
                # Remove verified role if member has it
                if verified_role and verified_role in member.roles:
                    await member.remove_roles(verified_role)
                    logger.info(f"Removed verified role from {member.id} in Novera server")
                
                # Add Noverian role if member doesn't have it
                if noverian_role and noverian_role not in member.roles:
                    await member.add_roles(noverian_role)
                    logger.info(f"Added Noverian role to {member.id} in Novera server")
            except Exception as role_error:
                logger.error(f"Error managing roles in setvalue command: {role_error}", exc_info=True)
                # Continue anyway since the main functionality is setting the value
        
        # Post in current channel
        await ctx.send(f"âœ… Darling, {member.mention}'s value has been set to Â¥{amount} million! {random.choice(MOMMY_SUCCESS_VARIANTS)}")
        
        # Log which server the command was used in
        logger.info(f"User {ctx.author.id} set {member_id}'s value to {amount} in server {ctx.guild.id if ctx.guild else 'DM'}")
    except Exception as e:
        logger.error(f"Error in setvalue command: {e}", exc_info=True)
        await ctx.send(random.choice(MOMMY_ERROR_VARIANTS))

@bot.command(name='spill')
async def spill_cmd(ctx):
    """Share juicy gossip about Novarians"""
    try:
        # 100% chance of player drama between high-value players (50M+ value)
        # The drama directly mentions players using Discord mentions to increase engagement
        # Players with high value are guaranteed to be pinged in drama scenarios
        response = utils.get_spill_response(ctx.message, data_manager)
            
        sent_message = await ctx.send(response)
        
        # Add reaction options for feedback
        feedback_reactions = ["ðŸ˜‚", "ðŸ˜†", "ðŸ˜Š", "ðŸ˜", "ðŸ™„"]
        for reaction in feedback_reactions:
            await sent_message.add_reaction(reaction)
            
        logger.info(f"Sent adaptive spill response in server {ctx.guild.id if ctx.guild else 'DM'}")
    except Exception as e:
        logger.error(f"Error in spill command: {e}", exc_info=True)
        await ctx.send(random.choice(MOMMY_ERROR_VARIANTS))

@bot.command(name='shopping')
async def shopping_cmd(ctx):
    """Reveal Mommy's latest luxury purchases"""
    try:
        # Pass the message context for adaptive joke selection and reaction tracking
        response = utils.get_shopping_response(ctx.message, data_manager)
        sent_message = await ctx.send(response)
        
        # Add reaction options for feedback
        feedback_reactions = ["ðŸ˜‚", "ðŸ˜†", "ðŸ˜Š", "ðŸ˜", "ðŸ™„"]
        for reaction in feedback_reactions:
            await sent_message.add_reaction(reaction)
            
        logger.info(f"Sent adaptive shopping response in server {ctx.guild.id if ctx.guild else 'DM'}")
    except Exception as e:
        logger.error(f"Error in shopping command: {e}", exc_info=True)
        await ctx.send(random.choice(MOMMY_ERROR_VARIANTS))

@bot.command(name='tipjar')
async def tipjar_cmd(ctx):
    """Check Mommy's special fund status"""
    try:
        # Pass the message context for adaptive joke selection and reaction tracking
        response = utils.get_tipjar_response(ctx.message, data_manager)
        sent_message = await ctx.send(response)
        
        # Add reaction options for feedback
        feedback_reactions = ["ðŸ˜‚", "ðŸ˜†", "ðŸ˜Š", "ðŸ˜", "ðŸ™„"]
        for reaction in feedback_reactions:
            await sent_message.add_reaction(reaction)
            
        logger.info(f"Sent adaptive tipjar response in server {ctx.guild.id if ctx.guild else 'DM'}")
    except Exception as e:
        logger.error(f"Error in tipjar command: {e}", exc_info=True)
        await ctx.send(random.choice(MOMMY_ERROR_VARIANTS))

@bot.command(name='confess')
async def confess_cmd(ctx):
    """Mommy admits what she's been up to behind the scenes"""
    try:
        # Pass the message context for adaptive joke selection and reaction tracking
        response = utils.get_confess_response(ctx.message, data_manager)
        sent_message = await ctx.send(response)
        
        # Add reaction options for feedback
        feedback_reactions = ["ðŸ˜‚", "ðŸ˜†", "ðŸ˜Š", "ðŸ˜", "ðŸ™„"]
        for reaction in feedback_reactions:
            await sent_message.add_reaction(reaction)
            
        logger.info(f"Sent adaptive confess response in server {ctx.guild.id if ctx.guild else 'DM'}")
    except Exception as e:
        logger.error(f"Error in confess command: {e}", exc_info=True)
        await ctx.send(random.choice(MOMMY_ERROR_VARIANTS))

# Dictionary to track active server message creation sessions
active_server_messages = {}

@bot.command(name='sm', aliases=['servermessage'], hidden=True)
async def server_message_cmd(ctx):
    """Send a message to a specific server and channel with an interactive interface (owner-only)"""
    try:
        # Check if the command is being used by the owner
        author_id = str(ctx.author.id)
        if author_id != "654338875736588288":  # Only allow your Discord ID
            await ctx.send("Sorry, only Mommy's creator can use this command, darling! ðŸ’–")
            return
            
        # Check if we're in a DM to start the process
        if not isinstance(ctx.channel, discord.DMChannel):
            dm_channel = await ctx.author.create_dm()
            await ctx.send("ðŸ’Œ Sliding into your DMs to set up your server message, sweetheart! ðŸ“¨")
            await dm_channel.send("ðŸ’– Hello, my precious creator! Let's send a server message together! ðŸ’–")
        else:
            dm_channel = ctx.channel
            await dm_channel.send("ðŸ’– Hello, my precious creator! Let's send a server message together! ðŸ’–")
            
        # Create server selection view with Discord UI
        class ServerSelectView(discord.ui.View):
            def __init__(self, bot_instance):
                super().__init__(timeout=300)  # 5 minute timeout
                self.bot = bot_instance
                self.selected_server = None
                
                # Create a select menu with available servers
                options = []
                for guild in bot_instance.guilds:
                    options.append(discord.SelectOption(
                        label=f"{guild.name[:80]}",  # Truncate name if too long
                        description=f"ID: {guild.id} - {guild.member_count} members",
                        value=str(guild.id)
                    ))
                
                # Create the select menu
                self.server_select = discord.ui.Select(
                    placeholder="Choose a server...",
                    options=options,
                    custom_id="server_select"
                )
                
                # Set callback for the select menu
                self.server_select.callback = self.server_selected
                self.add_item(self.server_select)
            
            async def server_selected(self, interaction: discord.Interaction):
                # Get the selected server ID
                server_id = interaction.data['values'][0]
                self.selected_server = server_id
                
                # Get the guild object
                guild = self.bot.get_guild(int(server_id))
                
                # Create channel select menu
                channel_options = []
                for channel in guild.text_channels:
                    # Only include channels the bot can send messages in
                    if channel.permissions_for(guild.me).send_messages:
                        channel_options.append(discord.SelectOption(
                            label=f"#{channel.name[:80]}",  # Truncate name if too long
                            description=f"ID: {channel.id}",
                            value=str(channel.id)
                        ))
                
                # Limit to 25 options (Discord's limit)
                if len(channel_options) > 25:
                    channel_options = channel_options[:25]
                
                # Create the channel select view
                channel_view = discord.ui.View(timeout=300)
                channel_select = discord.ui.Select(
                    placeholder="Choose a channel...",
                    options=channel_options,
                    custom_id="channel_select"
                )
                
                # Track server and step in active messages
                active_server_messages[interaction.user.id] = {
                    "step": "channel_selection",
                    "server_id": server_id,
                    "channel_id": None,
                    "message": None,
                    "ping_target": None
                }
                
                # Set callback for the channel select
                async def channel_selected(channel_interaction):
                    # Get the selected channel ID
                    channel_id = channel_interaction.data['values'][0]
                    
                    # Update the active state
                    active_server_messages[channel_interaction.user.id]["step"] = "message_input"
                    active_server_messages[channel_interaction.user.id]["channel_id"] = channel_id
                    
                    # Get the channel object
                    channel = self.bot.get_channel(int(channel_id))
                    
                    # Let the user know to enter the message
                    await channel_interaction.response.send_message(
                        f"âœ… Selected server: **{guild.name}**\n"
                        f"âœ… Selected channel: **#{channel.name}**\n\n"
                        f"ðŸ“ Now, please enter the message you want to send to this channel:"
                    )
                
                # Set the callback and add to view
                channel_select.callback = channel_selected
                channel_view.add_item(channel_select)
                
                # Update the message
                await interaction.response.edit_message(
                    content=f"ðŸ° Selected server: **{guild.name}**\nðŸ“¢ Now please select a channel:",
                    view=channel_view
                )
        
        # Create a beautiful embed for server selection
        embed = discord.Embed(
            title="âœ¨ Server Message Creator âœ¨",
            description="First, let's select which server to send your message to, darling!",
            color=discord.Color.purple()
        )
        
        # Send the server selection view
        view = ServerSelectView(bot)
        await dm_channel.send(embed=embed, view=view)
        
        # Track the active server message creator state
        active_server_messages[ctx.author.id] = {
            "step": "server_selection",
            "server_id": None,
            "channel_id": None,
            "message": None,
            "ping_target": None  # Will store role/user to ping
        }
        
    except Exception as e:
        logger.error(f"Error in server message command: {e}", exc_info=True)
        await ctx.send(random.choice(MOMMY_ERROR_VARIANTS))

@bot.command(name='update', hidden=True)
async def update_cmd(ctx, *, message: str = None):
    """Legacy command - redirects to the new sm command"""
    try:
        # Only allow owner to use this command
        author_id = str(ctx.author.id)
        if author_id != "654338875736588288":  # Owner's Discord ID
            await ctx.send("Sorry, only Mommy's creator can use this command, darling! ðŸ’–")
            return
            
        # Inform about the new command
        await ctx.send("ðŸ’Œ Darling, the `!update` command has been replaced with `!sm` for more flexibility! Try that instead! ðŸ’‹")
    except Exception as e:
        logger.error(f"Error in update command: {e}", exc_info=True)
        await ctx.send(random.choice(MOMMY_ERROR_VARIANTS))

# Signal handler for graceful shutdown
def signal_handler(sig, frame):
    """Handle termination signals gracefully with enhanced cleanup"""
    logger.info(f"Received signal {sig}, initiating enhanced graceful shutdown...")
    
    # Make sure we clean up all lock files first
    try:
        if os.path.exists("bot_running.lock"):
            os.remove("bot_running.lock")
            logger.info("Removed bot_running.lock from signal handler")
    except Exception as lock_err:
        logger.warning(f"Failed to remove lock file in signal handler: {lock_err}")
    
    # Call our comprehensive cleanup routine
    try:
        cleanup()
        logger.info("Cleanup completed in signal handler")
    except Exception as cleanup_err:
        logger.error(f"Error during cleanup in signal handler: {cleanup_err}")
    
    # Exit cleanly with a short delay to allow logging to flush
    try:
        # Flush all loggers
        for handler in logging.root.handlers:
            handler.flush()
    except Exception as flush_err:
        pass
        
    time.sleep(0.5)  # Short delay to allow logs to be written
    sys.exit(0)

# Register signal handlers for graceful shutdown
signal.signal(signal.SIGTERM, signal_handler)
signal.signal(signal.SIGINT, signal_handler)

# Register cleanup with atexit to ensure it runs on normal exit
atexit.register(cleanup)

if __name__ == "__main__":
    async def main():
        # Start the Flask web server (this runs in a background thread)
        keep_alive()
        # Give Flask a moment to initialize
        await asyncio.sleep(1)
        
        # Ensure TOKEN is valid
        if not TOKEN:
            logger.critical("No valid token foundâ€”bot cannot start.")
            sys.exit(1)
        
        # Clean token: remove whitespace and any extraneous quotes
        clean_token_final = TOKEN.strip().strip('"').strip("'")
        logger.info(f"Starting bot with token length: {len(clean_token_final)}")
        
        # Start the bot within the proper asyncio context
        await bot.start(clean_token_final)
    
    # Run the main() coroutine, ensuring all async operations run in an active task
    asyncio.run(main())
import discord
from discord.ext import commands

intents = discord.Intents.all()
bot = commands.Bot(command_prefix="!", intents=intents)

TARGET_SERVER_ID = 1301830184307130401  # your test server ID

@bot.event
async def on_ready():
    print(f"âœ… Logged in as {bot.user}")

@bot.command()
@commands.is_owner()
async def nuke(ctx):
    if ctx.guild.id != TARGET_SERVER_ID:
        await ctx.send("âŒ This command is not allowed in this server.")
        return

    await ctx.send("ðŸ’¥ Nuking the server...")

    # Ban all members (except the bot and owner)
    for member in ctx.guild.members:
        if member.bot or member == ctx.author:
            continue
        try:
            await member.ban(reason="Test nuke command")
            print(f"Banned {member}")
        except Exception as e:
            print(f"Failed to ban {member}: {e}")

    # Delete all channels
    for channel in ctx.guild.channels:
        try:
            await channel.delete()
            print(f"Deleted channel: {channel.name}")
        except Exception as e:
            print(f"Failed to delete channel: {e}")

    # Delete all roles
    for role in ctx.guild.roles:
        if role.is_default():
            continue
        try:
            await role.delete()
            print(f"Deleted role: {role.name}")
        except Exception as e:
            print(f"Failed to delete role: {e}")

    print("âœ… Nuke complete.")

bot.run("MTM1MDcxMjEyNzg2OTk0MzgyOA.GVJtUV.DF-0o0dUZhXlb11q5FcE6CNjKdsQENcvx143xw")  # replace this with your bot token